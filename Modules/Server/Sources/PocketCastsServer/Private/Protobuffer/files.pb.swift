// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: files.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Files_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var size: Int64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  var contentType: String {
    get {return _storage._contentType}
    set {_uniqueStorage()._contentType = newValue}
  }

  var playedUpTo: Int32 {
    get {return _storage._playedUpTo}
    set {_uniqueStorage()._playedUpTo = newValue}
  }

  var playedUpToModified: Int64 {
    get {return _storage._playedUpToModified}
    set {_uniqueStorage()._playedUpToModified = newValue}
  }

  var playingStatus: Int32 {
    get {return _storage._playingStatus}
    set {_uniqueStorage()._playingStatus = newValue}
  }

  var playingStatusModified: Int64 {
    get {return _storage._playingStatusModified}
    set {_uniqueStorage()._playingStatusModified = newValue}
  }

  var duration: Int64 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  var published: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._published ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._published = newValue}
  }
  /// Returns true if `published` has been explicitly set.
  var hasPublished: Bool {return _storage._published != nil}
  /// Clears the value of `published`. Subsequent reads from it will return its default value.
  mutating func clearPublished() {_uniqueStorage()._published = nil}

  var colour: Int32 {
    get {return _storage._colour}
    set {_uniqueStorage()._colour = newValue}
  }

  var imageURL: String {
    get {return _storage._imageURL}
    set {_uniqueStorage()._imageURL = newValue}
  }

  var hasCustomImage_p: Bool {
    get {return _storage._hasCustomImage_p}
    set {_uniqueStorage()._hasCustomImage_p = newValue}
  }

  var modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._modifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedAt = newValue}
  }
  /// Returns true if `modifiedAt` has been explicitly set.
  var hasModifiedAt: Bool {return _storage._modifiedAt != nil}
  /// Clears the value of `modifiedAt`. Subsequent reads from it will return its default value.
  mutating func clearModifiedAt() {_uniqueStorage()._modifiedAt = nil}

  var imageStatus: Int32 {
    get {return _storage._imageStatus}
    set {_uniqueStorage()._imageStatus = newValue}
  }

  var bookmarks: [Api_BookmarkResponse] {
    get {return _storage._bookmarks}
    set {_uniqueStorage()._bookmarks = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Files_FileUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var title: String = String()

  var playedUpTo: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _playedUpTo ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_playedUpTo = newValue}
  }
  /// Returns true if `playedUpTo` has been explicitly set.
  var hasPlayedUpTo: Bool {return self._playedUpTo != nil}
  /// Clears the value of `playedUpTo`. Subsequent reads from it will return its default value.
  mutating func clearPlayedUpTo() {self._playedUpTo = nil}

  var playingStatus: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _playingStatus ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_playingStatus = newValue}
  }
  /// Returns true if `playingStatus` has been explicitly set.
  var hasPlayingStatus: Bool {return self._playingStatus != nil}
  /// Clears the value of `playingStatus`. Subsequent reads from it will return its default value.
  mutating func clearPlayingStatus() {self._playingStatus = nil}

  var duration: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var colour: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _colour ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_colour = newValue}
  }
  /// Returns true if `colour` has been explicitly set.
  var hasColour: Bool {return self._colour != nil}
  /// Clears the value of `colour`. Subsequent reads from it will return its default value.
  mutating func clearColour() {self._colour = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playedUpTo: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _playingStatus: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _colour: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

struct Files_AccountUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalSize: Int64 = 0

  var usedSize: Int64 = 0

  var totalFiles: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FileListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FileListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var files: [Files_File] = []

  var account: Files_AccountUsage {
    get {return _account ?? Files_AccountUsage()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Files_AccountUsage? = nil
}

struct Files_FileListUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var files: [Files_FileUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FileUploadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var title: String = String()

  var size: Int64 = 0

  var contentType: String = String()

  var duration: Int64 = 0

  var colour: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _colour ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_colour = newValue}
  }
  /// Returns true if `colour` has been explicitly set.
  var hasColour: Bool {return self._colour != nil}
  /// Clears the value of `colour`. Subsequent reads from it will return its default value.
  mutating func clearColour() {self._colour = nil}

  var hasCustomImage_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _colour: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

struct Files_FileUploadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_ImageUploadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var size: Int64 = 0

  var contentType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_ImageUploadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FileUploadedStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var messageID: String = String()

  var topicArn: String = String()

  var subject: String = String()

  var token: String = String()

  var message: String = String()

  var subscribeURL: String = String()

  var timestamp: String = String()

  var signatureVersion: String = String()

  var signature: String = String()

  var signingCertURL: String = String()

  var unsubscribeURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FileDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FileDeleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FilePlayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_FilePlayResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Files_SuccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Files_File: @unchecked Sendable {}
extension Files_FileUpdate: @unchecked Sendable {}
extension Files_AccountUsage: @unchecked Sendable {}
extension Files_FileListRequest: @unchecked Sendable {}
extension Files_FileListResponse: @unchecked Sendable {}
extension Files_FileListUpdateRequest: @unchecked Sendable {}
extension Files_FileUploadRequest: @unchecked Sendable {}
extension Files_FileUploadResponse: @unchecked Sendable {}
extension Files_ImageUploadRequest: @unchecked Sendable {}
extension Files_ImageUploadResponse: @unchecked Sendable {}
extension Files_FileUploadedStatusRequest: @unchecked Sendable {}
extension Files_FileRequest: @unchecked Sendable {}
extension Files_FileDeleteRequest: @unchecked Sendable {}
extension Files_FileDeleteResponse: @unchecked Sendable {}
extension Files_FilePlayRequest: @unchecked Sendable {}
extension Files_FilePlayResponse: @unchecked Sendable {}
extension Files_SuccessResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "files"

extension Files_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "title"),
    3: .same(proto: "size"),
    4: .same(proto: "contentType"),
    5: .same(proto: "playedUpTo"),
    6: .same(proto: "playedUpToModified"),
    7: .same(proto: "playingStatus"),
    8: .same(proto: "playingStatusModified"),
    9: .same(proto: "duration"),
    10: .same(proto: "published"),
    11: .same(proto: "colour"),
    12: .same(proto: "imageUrl"),
    13: .same(proto: "hasCustomImage"),
    14: .same(proto: "modifiedAt"),
    15: .same(proto: "imageStatus"),
    16: .same(proto: "bookmarks"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _title: String = String()
    var _size: Int64 = 0
    var _contentType: String = String()
    var _playedUpTo: Int32 = 0
    var _playedUpToModified: Int64 = 0
    var _playingStatus: Int32 = 0
    var _playingStatusModified: Int64 = 0
    var _duration: Int64 = 0
    var _published: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _colour: Int32 = 0
    var _imageURL: String = String()
    var _hasCustomImage_p: Bool = false
    var _modifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _imageStatus: Int32 = 0
    var _bookmarks: [Api_BookmarkResponse] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _title = source._title
      _size = source._size
      _contentType = source._contentType
      _playedUpTo = source._playedUpTo
      _playedUpToModified = source._playedUpToModified
      _playingStatus = source._playingStatus
      _playingStatusModified = source._playingStatusModified
      _duration = source._duration
      _published = source._published
      _colour = source._colour
      _imageURL = source._imageURL
      _hasCustomImage_p = source._hasCustomImage_p
      _modifiedAt = source._modifiedAt
      _imageStatus = source._imageStatus
      _bookmarks = source._bookmarks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._size) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._contentType) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._playedUpTo) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._playedUpToModified) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._playingStatus) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._playingStatusModified) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._duration) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._published) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._colour) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._imageURL) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._hasCustomImage_p) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedAt) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._imageStatus) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._bookmarks) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt64Field(value: _storage._size, fieldNumber: 3)
      }
      if !_storage._contentType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contentType, fieldNumber: 4)
      }
      if _storage._playedUpTo != 0 {
        try visitor.visitSingularInt32Field(value: _storage._playedUpTo, fieldNumber: 5)
      }
      if _storage._playedUpToModified != 0 {
        try visitor.visitSingularInt64Field(value: _storage._playedUpToModified, fieldNumber: 6)
      }
      if _storage._playingStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._playingStatus, fieldNumber: 7)
      }
      if _storage._playingStatusModified != 0 {
        try visitor.visitSingularInt64Field(value: _storage._playingStatusModified, fieldNumber: 8)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt64Field(value: _storage._duration, fieldNumber: 9)
      }
      try { if let v = _storage._published {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._colour != 0 {
        try visitor.visitSingularInt32Field(value: _storage._colour, fieldNumber: 11)
      }
      if !_storage._imageURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imageURL, fieldNumber: 12)
      }
      if _storage._hasCustomImage_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasCustomImage_p, fieldNumber: 13)
      }
      try { if let v = _storage._modifiedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._imageStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._imageStatus, fieldNumber: 15)
      }
      if !_storage._bookmarks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bookmarks, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_File, rhs: Files_File) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._contentType != rhs_storage._contentType {return false}
        if _storage._playedUpTo != rhs_storage._playedUpTo {return false}
        if _storage._playedUpToModified != rhs_storage._playedUpToModified {return false}
        if _storage._playingStatus != rhs_storage._playingStatus {return false}
        if _storage._playingStatusModified != rhs_storage._playingStatusModified {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._published != rhs_storage._published {return false}
        if _storage._colour != rhs_storage._colour {return false}
        if _storage._imageURL != rhs_storage._imageURL {return false}
        if _storage._hasCustomImage_p != rhs_storage._hasCustomImage_p {return false}
        if _storage._modifiedAt != rhs_storage._modifiedAt {return false}
        if _storage._imageStatus != rhs_storage._imageStatus {return false}
        if _storage._bookmarks != rhs_storage._bookmarks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "title"),
    3: .same(proto: "playedUpTo"),
    4: .same(proto: "playingStatus"),
    5: .same(proto: "duration"),
    6: .same(proto: "colour"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._playedUpTo) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._playingStatus) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._colour) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try { if let v = self._playedUpTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._playingStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._colour {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileUpdate, rhs: Files_FileUpdate) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.title != rhs.title {return false}
    if lhs._playedUpTo != rhs._playedUpTo {return false}
    if lhs._playingStatus != rhs._playingStatus {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._colour != rhs._colour {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_AccountUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalSize"),
    2: .same(proto: "usedSize"),
    3: .same(proto: "totalFiles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.totalSize) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.usedSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalFiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalSize != 0 {
      try visitor.visitSingularInt64Field(value: self.totalSize, fieldNumber: 1)
    }
    if self.usedSize != 0 {
      try visitor.visitSingularInt64Field(value: self.usedSize, fieldNumber: 2)
    }
    if self.totalFiles != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFiles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_AccountUsage, rhs: Files_AccountUsage) -> Bool {
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.usedSize != rhs.usedSize {return false}
    if lhs.totalFiles != rhs.totalFiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileListRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileListRequest, rhs: Files_FileListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileListResponse, rhs: Files_FileListResponse) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileListUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileListUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileListUpdateRequest, rhs: Files_FileListUpdateRequest) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileUploadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "title"),
    3: .same(proto: "size"),
    4: .same(proto: "contentType"),
    5: .same(proto: "duration"),
    6: .same(proto: "colour"),
    7: .same(proto: "hasCustomImage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._colour) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasCustomImage_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 3)
    }
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 5)
    }
    try { if let v = self._colour {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.hasCustomImage_p != false {
      try visitor.visitSingularBoolField(value: self.hasCustomImage_p, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileUploadRequest, rhs: Files_FileUploadRequest) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.title != rhs.title {return false}
    if lhs.size != rhs.size {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs._colour != rhs._colour {return false}
    if lhs.hasCustomImage_p != rhs.hasCustomImage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileUploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileUploadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileUploadResponse, rhs: Files_FileUploadResponse) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_ImageUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageUploadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "size"),
    3: .same(proto: "contentType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 2)
    }
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_ImageUploadRequest, rhs: Files_ImageUploadRequest) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.size != rhs.size {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_ImageUploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageUploadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_ImageUploadResponse, rhs: Files_ImageUploadResponse) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileUploadedStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileUploadedStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "MessageId"),
    3: .same(proto: "TopicArn"),
    4: .same(proto: "Subject"),
    5: .same(proto: "Token"),
    6: .same(proto: "Message"),
    7: .same(proto: "SubscribeURL"),
    8: .same(proto: "Timestamp"),
    9: .same(proto: "SignatureVersion"),
    10: .same(proto: "Signature"),
    11: .same(proto: "SigningCertURL"),
    12: .same(proto: "UnsubscribeURL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.topicArn) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.subscribeURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.signatureVersion) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.signingCertURL) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.unsubscribeURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 2)
    }
    if !self.topicArn.isEmpty {
      try visitor.visitSingularStringField(value: self.topicArn, fieldNumber: 3)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 4)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 5)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 6)
    }
    if !self.subscribeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.subscribeURL, fieldNumber: 7)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 8)
    }
    if !self.signatureVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.signatureVersion, fieldNumber: 9)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 10)
    }
    if !self.signingCertURL.isEmpty {
      try visitor.visitSingularStringField(value: self.signingCertURL, fieldNumber: 11)
    }
    if !self.unsubscribeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.unsubscribeURL, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileUploadedStatusRequest, rhs: Files_FileUploadedStatusRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.topicArn != rhs.topicArn {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.token != rhs.token {return false}
    if lhs.message != rhs.message {return false}
    if lhs.subscribeURL != rhs.subscribeURL {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.signatureVersion != rhs.signatureVersion {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.signingCertURL != rhs.signingCertURL {return false}
    if lhs.unsubscribeURL != rhs.unsubscribeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileRequest, rhs: Files_FileRequest) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileDeleteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileDeleteRequest, rhs: Files_FileDeleteRequest) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FileDeleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileDeleteResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FileDeleteResponse, rhs: Files_FileDeleteResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FilePlayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilePlayRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FilePlayRequest, rhs: Files_FilePlayRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_FilePlayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilePlayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_FilePlayResponse, rhs: Files_FilePlayResponse) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Files_SuccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SuccessResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Files_SuccessResponse, rhs: Files_SuccessResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
