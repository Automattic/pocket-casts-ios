// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Api_UserChangeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _success ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_success = newValue}
  }
  /// Returns true if `success` has been explicitly set.
  var hasSuccess: Bool {return self._success != nil}
  /// Clears the value of `success`. Subsequent reads from it will return its default value.
  mutating func clearSuccess() {self._success = nil}

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _success: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

struct Api_UserResetPasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resetPasswordToken: String = String()

  var password: String = String()

  var scope: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_EmailRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserChangeEmailRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var password: String = String()

  var scope: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserChangePasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oldPassword: String = String()

  var newPassword: String = String()

  var scope: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_EmptyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_EmptyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SupportFeedbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var email: String = String()

  var subject: String = String()

  var debug: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_CreateBetaUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var password: String = String()

  var scope: String = String()

  var dt: String = String()

  var device: String = String()

  /// app version
  var v: String = String()

  /// device model
  var m: String = String()

  /// api version
  var av: String = String()

  /// lite version
  var f: String = String()

  /// language code
  var l: String = String()

  /// country code
  var c: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_BasicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var v: String = String()

  var m: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// FindUserPodcasts
struct Api_UserPlaylistEpisodesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var v: String = String()

  var m: String = String()

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserPlaylistListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var v: String = String()

  var m: String = String()

  var excludeDeleted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserPodcastListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var v: String = String()

  var m: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_NamedSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var v: String = String()

  var m: String = String()

  var settings: Api_NamedSettings {
    get {return _settings ?? Api_NamedSettings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {self._settings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _settings: Api_NamedSettings? = nil
}

struct Api_NamedSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gridLayout: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._gridLayout ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._gridLayout = newValue}
  }
  /// Returns true if `gridLayout` has been explicitly set.
  var hasGridLayout: Bool {return _storage._gridLayout != nil}
  /// Clears the value of `gridLayout`. Subsequent reads from it will return its default value.
  mutating func clearGridLayout() {_uniqueStorage()._gridLayout = nil}

  var gridOrder: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._gridOrder ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._gridOrder = newValue}
  }
  /// Returns true if `gridOrder` has been explicitly set.
  var hasGridOrder: Bool {return _storage._gridOrder != nil}
  /// Clears the value of `gridOrder`. Subsequent reads from it will return its default value.
  mutating func clearGridOrder() {_uniqueStorage()._gridOrder = nil}

  var showPlayed: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._showPlayed ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._showPlayed = newValue}
  }
  /// Returns true if `showPlayed` has been explicitly set.
  var hasShowPlayed: Bool {return _storage._showPlayed != nil}
  /// Clears the value of `showPlayed`. Subsequent reads from it will return its default value.
  mutating func clearShowPlayed() {_uniqueStorage()._showPlayed = nil}

  var theme: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._theme ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {_uniqueStorage()._theme = nil}

  var skipForward: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._skipForward ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._skipForward = newValue}
  }
  /// Returns true if `skipForward` has been explicitly set.
  var hasSkipForward: Bool {return _storage._skipForward != nil}
  /// Clears the value of `skipForward`. Subsequent reads from it will return its default value.
  mutating func clearSkipForward() {_uniqueStorage()._skipForward = nil}

  var skipBack: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._skipBack ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._skipBack = newValue}
  }
  /// Returns true if `skipBack` has been explicitly set.
  var hasSkipBack: Bool {return _storage._skipBack != nil}
  /// Clears the value of `skipBack`. Subsequent reads from it will return its default value.
  mutating func clearSkipBack() {_uniqueStorage()._skipBack = nil}

  var webVersion: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._webVersion ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._webVersion = newValue}
  }
  /// Returns true if `webVersion` has been explicitly set.
  var hasWebVersion: Bool {return _storage._webVersion != nil}
  /// Clears the value of `webVersion`. Subsequent reads from it will return its default value.
  mutating func clearWebVersion() {_uniqueStorage()._webVersion = nil}

  var language: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._language ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  var hasLanguage: Bool {return _storage._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  mutating func clearLanguage() {_uniqueStorage()._language = nil}

  var recommendationsOn: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._recommendationsOn ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._recommendationsOn = newValue}
  }
  /// Returns true if `recommendationsOn` has been explicitly set.
  var hasRecommendationsOn: Bool {return _storage._recommendationsOn != nil}
  /// Clears the value of `recommendationsOn`. Subsequent reads from it will return its default value.
  mutating func clearRecommendationsOn() {_uniqueStorage()._recommendationsOn = nil}

  var streamByDefault: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._streamByDefault ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._streamByDefault = newValue}
  }
  /// Returns true if `streamByDefault` has been explicitly set.
  var hasStreamByDefault: Bool {return _storage._streamByDefault != nil}
  /// Clears the value of `streamByDefault`. Subsequent reads from it will return its default value.
  mutating func clearStreamByDefault() {_uniqueStorage()._streamByDefault = nil}

  var useEmbeddedArtwork: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._useEmbeddedArtwork ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._useEmbeddedArtwork = newValue}
  }
  /// Returns true if `useEmbeddedArtwork` has been explicitly set.
  var hasUseEmbeddedArtwork: Bool {return _storage._useEmbeddedArtwork != nil}
  /// Clears the value of `useEmbeddedArtwork`. Subsequent reads from it will return its default value.
  mutating func clearUseEmbeddedArtwork() {_uniqueStorage()._useEmbeddedArtwork = nil}

  var playbackSpeed: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._playbackSpeed ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._playbackSpeed = newValue}
  }
  /// Returns true if `playbackSpeed` has been explicitly set.
  var hasPlaybackSpeed: Bool {return _storage._playbackSpeed != nil}
  /// Clears the value of `playbackSpeed`. Subsequent reads from it will return its default value.
  mutating func clearPlaybackSpeed() {_uniqueStorage()._playbackSpeed = nil}

  var silenceRemoval: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._silenceRemoval ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._silenceRemoval = newValue}
  }
  /// Returns true if `silenceRemoval` has been explicitly set.
  var hasSilenceRemoval: Bool {return _storage._silenceRemoval != nil}
  /// Clears the value of `silenceRemoval`. Subsequent reads from it will return its default value.
  mutating func clearSilenceRemoval() {_uniqueStorage()._silenceRemoval = nil}

  var volumeBoost: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._volumeBoost ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._volumeBoost = newValue}
  }
  /// Returns true if `volumeBoost` has been explicitly set.
  var hasVolumeBoost: Bool {return _storage._volumeBoost != nil}
  /// Clears the value of `volumeBoost`. Subsequent reads from it will return its default value.
  mutating func clearVolumeBoost() {_uniqueStorage()._volumeBoost = nil}

  var badges: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._badges ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._badges = newValue}
  }
  /// Returns true if `badges` has been explicitly set.
  var hasBadges: Bool {return _storage._badges != nil}
  /// Clears the value of `badges`. Subsequent reads from it will return its default value.
  mutating func clearBadges() {_uniqueStorage()._badges = nil}

  var freeGiftAcknowledgement: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._freeGiftAcknowledgement ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._freeGiftAcknowledgement = newValue}
  }
  /// Returns true if `freeGiftAcknowledgement` has been explicitly set.
  var hasFreeGiftAcknowledgement: Bool {return _storage._freeGiftAcknowledgement != nil}
  /// Clears the value of `freeGiftAcknowledgement`. Subsequent reads from it will return its default value.
  mutating func clearFreeGiftAcknowledgement() {_uniqueStorage()._freeGiftAcknowledgement = nil}

  var marketingOptIn: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._marketingOptIn ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._marketingOptIn = newValue}
  }
  /// Returns true if `marketingOptIn` has been explicitly set.
  var hasMarketingOptIn: Bool {return _storage._marketingOptIn != nil}
  /// Clears the value of `marketingOptIn`. Subsequent reads from it will return its default value.
  mutating func clearMarketingOptIn() {_uniqueStorage()._marketingOptIn = nil}

  var autoArchivePlayedEpisodes: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._autoArchivePlayedEpisodes ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._autoArchivePlayedEpisodes = newValue}
  }
  /// Returns true if `autoArchivePlayedEpisodes` has been explicitly set.
  var hasAutoArchivePlayedEpisodes: Bool {return _storage._autoArchivePlayedEpisodes != nil}
  /// Clears the value of `autoArchivePlayedEpisodes`. Subsequent reads from it will return its default value.
  mutating func clearAutoArchivePlayedEpisodes() {_uniqueStorage()._autoArchivePlayedEpisodes = nil}

  var autoArchiveIncludesStarred: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._autoArchiveIncludesStarred ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._autoArchiveIncludesStarred = newValue}
  }
  /// Returns true if `autoArchiveIncludesStarred` has been explicitly set.
  var hasAutoArchiveIncludesStarred: Bool {return _storage._autoArchiveIncludesStarred != nil}
  /// Clears the value of `autoArchiveIncludesStarred`. Subsequent reads from it will return its default value.
  mutating func clearAutoArchiveIncludesStarred() {_uniqueStorage()._autoArchiveIncludesStarred = nil}

  var region: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._region ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  var hasRegion: Bool {return _storage._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  mutating func clearRegion() {_uniqueStorage()._region = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_NamedSettingsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gridLayout: Api_Int32Setting {
    get {return _storage._gridLayout ?? Api_Int32Setting()}
    set {_uniqueStorage()._gridLayout = newValue}
  }
  /// Returns true if `gridLayout` has been explicitly set.
  var hasGridLayout: Bool {return _storage._gridLayout != nil}
  /// Clears the value of `gridLayout`. Subsequent reads from it will return its default value.
  mutating func clearGridLayout() {_uniqueStorage()._gridLayout = nil}

  var gridOrder: Api_Int32Setting {
    get {return _storage._gridOrder ?? Api_Int32Setting()}
    set {_uniqueStorage()._gridOrder = newValue}
  }
  /// Returns true if `gridOrder` has been explicitly set.
  var hasGridOrder: Bool {return _storage._gridOrder != nil}
  /// Clears the value of `gridOrder`. Subsequent reads from it will return its default value.
  mutating func clearGridOrder() {_uniqueStorage()._gridOrder = nil}

  var showPlayed: Api_Int32Setting {
    get {return _storage._showPlayed ?? Api_Int32Setting()}
    set {_uniqueStorage()._showPlayed = newValue}
  }
  /// Returns true if `showPlayed` has been explicitly set.
  var hasShowPlayed: Bool {return _storage._showPlayed != nil}
  /// Clears the value of `showPlayed`. Subsequent reads from it will return its default value.
  mutating func clearShowPlayed() {_uniqueStorage()._showPlayed = nil}

  var theme: Api_Int32Setting {
    get {return _storage._theme ?? Api_Int32Setting()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {_uniqueStorage()._theme = nil}

  var skipForward: Api_Int32Setting {
    get {return _storage._skipForward ?? Api_Int32Setting()}
    set {_uniqueStorage()._skipForward = newValue}
  }
  /// Returns true if `skipForward` has been explicitly set.
  var hasSkipForward: Bool {return _storage._skipForward != nil}
  /// Clears the value of `skipForward`. Subsequent reads from it will return its default value.
  mutating func clearSkipForward() {_uniqueStorage()._skipForward = nil}

  var skipBack: Api_Int32Setting {
    get {return _storage._skipBack ?? Api_Int32Setting()}
    set {_uniqueStorage()._skipBack = newValue}
  }
  /// Returns true if `skipBack` has been explicitly set.
  var hasSkipBack: Bool {return _storage._skipBack != nil}
  /// Clears the value of `skipBack`. Subsequent reads from it will return its default value.
  mutating func clearSkipBack() {_uniqueStorage()._skipBack = nil}

  var webVersion: Api_Int32Setting {
    get {return _storage._webVersion ?? Api_Int32Setting()}
    set {_uniqueStorage()._webVersion = newValue}
  }
  /// Returns true if `webVersion` has been explicitly set.
  var hasWebVersion: Bool {return _storage._webVersion != nil}
  /// Clears the value of `webVersion`. Subsequent reads from it will return its default value.
  mutating func clearWebVersion() {_uniqueStorage()._webVersion = nil}

  var language: Api_StringSetting {
    get {return _storage._language ?? Api_StringSetting()}
    set {_uniqueStorage()._language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  var hasLanguage: Bool {return _storage._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  mutating func clearLanguage() {_uniqueStorage()._language = nil}

  var recommendationsOn: Api_BoolSetting {
    get {return _storage._recommendationsOn ?? Api_BoolSetting()}
    set {_uniqueStorage()._recommendationsOn = newValue}
  }
  /// Returns true if `recommendationsOn` has been explicitly set.
  var hasRecommendationsOn: Bool {return _storage._recommendationsOn != nil}
  /// Clears the value of `recommendationsOn`. Subsequent reads from it will return its default value.
  mutating func clearRecommendationsOn() {_uniqueStorage()._recommendationsOn = nil}

  var streamByDefault: Api_BoolSetting {
    get {return _storage._streamByDefault ?? Api_BoolSetting()}
    set {_uniqueStorage()._streamByDefault = newValue}
  }
  /// Returns true if `streamByDefault` has been explicitly set.
  var hasStreamByDefault: Bool {return _storage._streamByDefault != nil}
  /// Clears the value of `streamByDefault`. Subsequent reads from it will return its default value.
  mutating func clearStreamByDefault() {_uniqueStorage()._streamByDefault = nil}

  var useEmbeddedArtwork: Api_BoolSetting {
    get {return _storage._useEmbeddedArtwork ?? Api_BoolSetting()}
    set {_uniqueStorage()._useEmbeddedArtwork = newValue}
  }
  /// Returns true if `useEmbeddedArtwork` has been explicitly set.
  var hasUseEmbeddedArtwork: Bool {return _storage._useEmbeddedArtwork != nil}
  /// Clears the value of `useEmbeddedArtwork`. Subsequent reads from it will return its default value.
  mutating func clearUseEmbeddedArtwork() {_uniqueStorage()._useEmbeddedArtwork = nil}

  var playbackSpeed: Api_DoubleSetting {
    get {return _storage._playbackSpeed ?? Api_DoubleSetting()}
    set {_uniqueStorage()._playbackSpeed = newValue}
  }
  /// Returns true if `playbackSpeed` has been explicitly set.
  var hasPlaybackSpeed: Bool {return _storage._playbackSpeed != nil}
  /// Clears the value of `playbackSpeed`. Subsequent reads from it will return its default value.
  mutating func clearPlaybackSpeed() {_uniqueStorage()._playbackSpeed = nil}

  var silenceRemoval: Api_BoolSetting {
    get {return _storage._silenceRemoval ?? Api_BoolSetting()}
    set {_uniqueStorage()._silenceRemoval = newValue}
  }
  /// Returns true if `silenceRemoval` has been explicitly set.
  var hasSilenceRemoval: Bool {return _storage._silenceRemoval != nil}
  /// Clears the value of `silenceRemoval`. Subsequent reads from it will return its default value.
  mutating func clearSilenceRemoval() {_uniqueStorage()._silenceRemoval = nil}

  var volumeBoost: Api_BoolSetting {
    get {return _storage._volumeBoost ?? Api_BoolSetting()}
    set {_uniqueStorage()._volumeBoost = newValue}
  }
  /// Returns true if `volumeBoost` has been explicitly set.
  var hasVolumeBoost: Bool {return _storage._volumeBoost != nil}
  /// Clears the value of `volumeBoost`. Subsequent reads from it will return its default value.
  mutating func clearVolumeBoost() {_uniqueStorage()._volumeBoost = nil}

  var badges: Api_Int32Setting {
    get {return _storage._badges ?? Api_Int32Setting()}
    set {_uniqueStorage()._badges = newValue}
  }
  /// Returns true if `badges` has been explicitly set.
  var hasBadges: Bool {return _storage._badges != nil}
  /// Clears the value of `badges`. Subsequent reads from it will return its default value.
  mutating func clearBadges() {_uniqueStorage()._badges = nil}

  var freeGiftAcknowledgement: Api_BoolSetting {
    get {return _storage._freeGiftAcknowledgement ?? Api_BoolSetting()}
    set {_uniqueStorage()._freeGiftAcknowledgement = newValue}
  }
  /// Returns true if `freeGiftAcknowledgement` has been explicitly set.
  var hasFreeGiftAcknowledgement: Bool {return _storage._freeGiftAcknowledgement != nil}
  /// Clears the value of `freeGiftAcknowledgement`. Subsequent reads from it will return its default value.
  mutating func clearFreeGiftAcknowledgement() {_uniqueStorage()._freeGiftAcknowledgement = nil}

  var marketingOptIn: Api_BoolSetting {
    get {return _storage._marketingOptIn ?? Api_BoolSetting()}
    set {_uniqueStorage()._marketingOptIn = newValue}
  }
  /// Returns true if `marketingOptIn` has been explicitly set.
  var hasMarketingOptIn: Bool {return _storage._marketingOptIn != nil}
  /// Clears the value of `marketingOptIn`. Subsequent reads from it will return its default value.
  mutating func clearMarketingOptIn() {_uniqueStorage()._marketingOptIn = nil}

  var autoArchivePlayedEpisodes: Api_BoolSetting {
    get {return _storage._autoArchivePlayedEpisodes ?? Api_BoolSetting()}
    set {_uniqueStorage()._autoArchivePlayedEpisodes = newValue}
  }
  /// Returns true if `autoArchivePlayedEpisodes` has been explicitly set.
  var hasAutoArchivePlayedEpisodes: Bool {return _storage._autoArchivePlayedEpisodes != nil}
  /// Clears the value of `autoArchivePlayedEpisodes`. Subsequent reads from it will return its default value.
  mutating func clearAutoArchivePlayedEpisodes() {_uniqueStorage()._autoArchivePlayedEpisodes = nil}

  var autoArchiveIncludesStarred: Api_BoolSetting {
    get {return _storage._autoArchiveIncludesStarred ?? Api_BoolSetting()}
    set {_uniqueStorage()._autoArchiveIncludesStarred = newValue}
  }
  /// Returns true if `autoArchiveIncludesStarred` has been explicitly set.
  var hasAutoArchiveIncludesStarred: Bool {return _storage._autoArchiveIncludesStarred != nil}
  /// Clears the value of `autoArchiveIncludesStarred`. Subsequent reads from it will return its default value.
  mutating func clearAutoArchiveIncludesStarred() {_uniqueStorage()._autoArchiveIncludesStarred = nil}

  var region: Api_StringSetting {
    get {return _storage._region ?? Api_StringSetting()}
    set {_uniqueStorage()._region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  var hasRegion: Bool {return _storage._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  mutating func clearRegion() {_uniqueStorage()._region = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_Int32Setting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _value ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var changed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _changed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_changed = newValue}
  }
  /// Returns true if `changed` has been explicitly set.
  var hasChanged: Bool {return self._changed != nil}
  /// Clears the value of `changed`. Subsequent reads from it will return its default value.
  mutating func clearChanged() {self._changed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _changed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

struct Api_BoolSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _value ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var changed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _changed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_changed = newValue}
  }
  /// Returns true if `changed` has been explicitly set.
  var hasChanged: Bool {return self._changed != nil}
  /// Clears the value of `changed`. Subsequent reads from it will return its default value.
  mutating func clearChanged() {self._changed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _changed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

struct Api_StringSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _value ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var changed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _changed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_changed = newValue}
  }
  /// Returns true if `changed` has been explicitly set.
  var hasChanged: Bool {return self._changed != nil}
  /// Clears the value of `changed`. Subsequent reads from it will return its default value.
  mutating func clearChanged() {self._changed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _changed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

struct Api_DoubleSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _value ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var changed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _changed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_changed = newValue}
  }
  /// Returns true if `changed` has been explicitly set.
  var hasChanged: Bool {return self._changed != nil}
  /// Clears the value of `changed`. Subsequent reads from it will return its default value.
  mutating func clearChanged() {self._changed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _changed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

struct Api_ApiPodcastResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var title: String = String()

  var author: String = String()

  var description_p: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_ApiPodcastListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcasts: [Api_ApiPodcastResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserPodcastResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var episodesSortOrder: Int32 {
    get {return _storage._episodesSortOrder}
    set {_uniqueStorage()._episodesSortOrder = newValue}
  }

  var autoStartFrom: Int32 {
    get {return _storage._autoStartFrom}
    set {_uniqueStorage()._autoStartFrom = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var author: String {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  var lastEpisodePublished: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastEpisodePublished ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastEpisodePublished = newValue}
  }
  /// Returns true if `lastEpisodePublished` has been explicitly set.
  var hasLastEpisodePublished: Bool {return _storage._lastEpisodePublished != nil}
  /// Clears the value of `lastEpisodePublished`. Subsequent reads from it will return its default value.
  mutating func clearLastEpisodePublished() {_uniqueStorage()._lastEpisodePublished = nil}

  var unplayed: Bool {
    get {return _storage._unplayed}
    set {_uniqueStorage()._unplayed = newValue}
  }

  var lastEpisodeUuid: String {
    get {return _storage._lastEpisodeUuid}
    set {_uniqueStorage()._lastEpisodeUuid = newValue}
  }

  var lastEpisodePlayingStatus: Int32 {
    get {return _storage._lastEpisodePlayingStatus}
    set {_uniqueStorage()._lastEpisodePlayingStatus = newValue}
  }

  var lastEpisodeArchived: Bool {
    get {return _storage._lastEpisodeArchived}
    set {_uniqueStorage()._lastEpisodeArchived = newValue}
  }

  var autoSkipLast: Int32 {
    get {return _storage._autoSkipLast}
    set {_uniqueStorage()._autoSkipLast = newValue}
  }

  var folderUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._folderUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._folderUuid = newValue}
  }
  /// Returns true if `folderUuid` has been explicitly set.
  var hasFolderUuid: Bool {return _storage._folderUuid != nil}
  /// Clears the value of `folderUuid`. Subsequent reads from it will return its default value.
  mutating func clearFolderUuid() {_uniqueStorage()._folderUuid = nil}

  var sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortPosition ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortPosition = newValue}
  }
  /// Returns true if `sortPosition` has been explicitly set.
  var hasSortPosition: Bool {return _storage._sortPosition != nil}
  /// Clears the value of `sortPosition`. Subsequent reads from it will return its default value.
  mutating func clearSortPosition() {_uniqueStorage()._sortPosition = nil}

  var dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateAdded ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateAdded = newValue}
  }
  /// Returns true if `dateAdded` has been explicitly set.
  var hasDateAdded: Bool {return _storage._dateAdded != nil}
  /// Clears the value of `dateAdded`. Subsequent reads from it will return its default value.
  mutating func clearDateAdded() {_uniqueStorage()._dateAdded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_UserPlaylistListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playlists: [Api_PlaylistSyncResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserPodcastListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcasts: [Api_UserPodcastResponse] = []

  var folders: [Api_PodcastFolder] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserLastSyncAtResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastSyncAt: String = String()

  var lastSyncAtMs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UuidRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var v: String = String()

  var m: String = String()

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_KeywordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var v: String = String()

  var m: String = String()

  var keyword: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SyncEpisodesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var episodes: [Api_EpisodeSyncResponse] = []

  var autoStartFrom: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _autoStartFrom ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_autoStartFrom = newValue}
  }
  /// Returns true if `autoStartFrom` has been explicitly set.
  var hasAutoStartFrom: Bool {return self._autoStartFrom != nil}
  /// Clears the value of `autoStartFrom`. Subsequent reads from it will return its default value.
  mutating func clearAutoStartFrom() {self._autoStartFrom = nil}

  var episodesSortOrder: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _episodesSortOrder ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_episodesSortOrder = newValue}
  }
  /// Returns true if `episodesSortOrder` has been explicitly set.
  var hasEpisodesSortOrder: Bool {return self._episodesSortOrder != nil}
  /// Clears the value of `episodesSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearEpisodesSortOrder() {self._episodesSortOrder = nil}

  var autoSkipLast: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _autoSkipLast ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_autoSkipLast = newValue}
  }
  /// Returns true if `autoSkipLast` has been explicitly set.
  var hasAutoSkipLast: Bool {return self._autoSkipLast != nil}
  /// Clears the value of `autoSkipLast`. Subsequent reads from it will return its default value.
  mutating func clearAutoSkipLast() {self._autoSkipLast = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _autoStartFrom: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _episodesSortOrder: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _autoSkipLast: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

struct Api_FindUserEpisodesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastUuid: String = String()

  var page: Int32 = 0

  var sort: Int32 = 0

  var v: String = String()

  var m: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_EpisodesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var total: Int32 = 0

  var episodes: [Api_EpisodeResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_FindUserEpisodeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var v: String = String()

  var m: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_EpisodeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  var published: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._published ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._published = newValue}
  }
  /// Returns true if `published` has been explicitly set.
  var hasPublished: Bool {return _storage._published != nil}
  /// Clears the value of `published`. Subsequent reads from it will return its default value.
  mutating func clearPublished() {_uniqueStorage()._published = nil}

  var duration: Int32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  var fileType: String {
    get {return _storage._fileType}
    set {_uniqueStorage()._fileType = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var size: Int64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  var playingStatus: Int32 {
    get {return _storage._playingStatus}
    set {_uniqueStorage()._playingStatus = newValue}
  }

  var playedUpTo: Int32 {
    get {return _storage._playedUpTo}
    set {_uniqueStorage()._playedUpTo = newValue}
  }

  var starred: Bool {
    get {return _storage._starred}
    set {_uniqueStorage()._starred = newValue}
  }

  var podcastUuid: String {
    get {return _storage._podcastUuid}
    set {_uniqueStorage()._podcastUuid = newValue}
  }

  var podcastTitle: String {
    get {return _storage._podcastTitle}
    set {_uniqueStorage()._podcastTitle = newValue}
  }

  var episodeType: String {
    get {return _storage._episodeType}
    set {_uniqueStorage()._episodeType = newValue}
  }

  var episodeSeason: Int32 {
    get {return _storage._episodeSeason}
    set {_uniqueStorage()._episodeSeason = newValue}
  }

  var episodeNumber: Int32 {
    get {return _storage._episodeNumber}
    set {_uniqueStorage()._episodeNumber = newValue}
  }

  var isDeleted: Bool {
    get {return _storage._isDeleted}
    set {_uniqueStorage()._isDeleted = newValue}
  }

  var author: String {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_SyncUpdateEpisodeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UpdateEpisodeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var podcast: String = String()

  var position: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _position ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var status: Int32 = 0

  var duration: Int32 = 0

  var stats: Api_StatsRequest {
    get {return _stats ?? Api_StatsRequest()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  mutating func clearStats() {self._stats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _stats: Api_StatsRequest? = nil
}

struct Api_UpdateEpisodeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_StatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var timeSilenceRemoval: Int32 = 0

  var timeSkipping: Int32 = 0

  var timeIntroSkipping: Int32 = 0

  var timeVariableSpeed: Int32 = 0

  var timeListened: Int32 = 0

  var deviceType: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UpdateEpisodeStarRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var podcast: String = String()

  var star: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UpdateEpisodeStarResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_EpisodeWithPodcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var podcast: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UpdateEpisodesArchiveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var archive: Bool = false

  var episodes: [Api_EpisodeWithPodcast] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UpNextSyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceTime: Int64 = 0

  var version: String = String()

  var model: String = String()

  var upNext: Api_UpNextChanges {
    get {return _upNext ?? Api_UpNextChanges()}
    set {_upNext = newValue}
  }
  /// Returns true if `upNext` has been explicitly set.
  var hasUpNext: Bool {return self._upNext != nil}
  /// Clears the value of `upNext`. Subsequent reads from it will return its default value.
  mutating func clearUpNext() {self._upNext = nil}

  var showPlayStatus: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _upNext: Api_UpNextChanges? = nil
}

struct Api_UpNextPlayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var model: String = String()

  var episode: Api_UpNextEpisodeRequest {
    get {return _episode ?? Api_UpNextEpisodeRequest()}
    set {_episode = newValue}
  }
  /// Returns true if `episode` has been explicitly set.
  var hasEpisode: Bool {return self._episode != nil}
  /// Clears the value of `episode`. Subsequent reads from it will return its default value.
  mutating func clearEpisode() {self._episode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _episode: Api_UpNextEpisodeRequest? = nil
}

struct Api_UpNextListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limit: Int32 = 0

  var version: String = String()

  var model: String = String()

  var serverModified: Int64 = 0

  var showPlayStatus: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UpNextEpisodeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var title: String = String()

  var url: String = String()

  var podcast: String = String()

  var published: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _published ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_published = newValue}
  }
  /// Returns true if `published` has been explicitly set.
  var hasPublished: Bool {return self._published != nil}
  /// Clears the value of `published`. Subsequent reads from it will return its default value.
  mutating func clearPublished() {self._published = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _published: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_UpNextChanges {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverModified: Int64 = 0

  var changes: [Api_UpNextChanges.Change] = []

  var order: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Change {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: String = String()

    var action: Int32 = 0

    var modified: Int64 = 0

    var title: String = String()

    var url: String = String()

    var podcast: String = String()

    var episodes: [Api_UpNextEpisodeRequest] = []

    var published: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _published ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_published = newValue}
    }
    /// Returns true if `published` has been explicitly set.
    var hasPublished: Bool {return self._published != nil}
    /// Clears the value of `published`. Subsequent reads from it will return its default value.
    mutating func clearPublished() {self._published = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _published: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  init() {}
}

struct Api_UpNextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverModified: Int64 = 0

  var episodes: [Api_UpNextResponse.EpisodeResponse] = []

  var episodeSync: [Api_UpNextResponse.EpisodeSyncResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct EpisodeResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var title: String = String()

    var url: String = String()

    var podcast: String = String()

    var uuid: String = String()

    var published: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _published ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_published = newValue}
    }
    /// Returns true if `published` has been explicitly set.
    var hasPublished: Bool {return self._published != nil}
    /// Clears the value of `published`. Subsequent reads from it will return its default value.
    mutating func clearPublished() {self._published = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _published: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  struct EpisodeSyncResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: String = String()

    var playedUpTo: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _playedUpTo ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_playedUpTo = newValue}
    }
    /// Returns true if `playedUpTo` has been explicitly set.
    var hasPlayedUpTo: Bool {return self._playedUpTo != nil}
    /// Clears the value of `playedUpTo`. Subsequent reads from it will return its default value.
    mutating func clearPlayedUpTo() {self._playedUpTo = nil}

    var duration: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _duration ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_duration = newValue}
    }
    /// Returns true if `duration` has been explicitly set.
    var hasDuration: Bool {return self._duration != nil}
    /// Clears the value of `duration`. Subsequent reads from it will return its default value.
    mutating func clearDuration() {self._duration = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _playedUpTo: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  }

  init() {}
}

struct Api_HistoryChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: Int32 = 0

  var podcast: String = String()

  var episode: String = String()

  var modifiedAt: Int64 = 0

  var title: String = String()

  var url: String = String()

  var published: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _published ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_published = newValue}
  }
  /// Returns true if `published` has been explicitly set.
  var hasPublished: Bool {return self._published != nil}
  /// Clears the value of `published`. Subsequent reads from it will return its default value.
  mutating func clearPublished() {self._published = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _published: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_HistorySyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceTime: Int64 = 0

  var serverModified: Int64 = 0

  var changes: [Api_HistoryChange] = []

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_HistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverModified: Int64 = 0

  var lastCleared: Int64 = 0

  var changes: [Api_HistoryChange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UpNextRemoveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuids: [String] = []

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_EpisodeSyncResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var playingStatus: Int32 = 0

  var playedUpTo: Int32 = 0

  var isDeleted: Bool = false

  var starred: Bool = false

  var duration: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SearchPodcastsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var term: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_HealthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ok: Bool = false

  var messages: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_StatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeSilenceRemoval: Int64 = 0

  var timeSkipping: Int64 = 0

  var timeIntroSkipping: Int64 = 0

  var timeVariableSpeed: Int64 = 0

  var timeListened: Int64 = 0

  var timesStartedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timesStartedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timesStartedAt = newValue}
  }
  /// Returns true if `timesStartedAt` has been explicitly set.
  var hasTimesStartedAt: Bool {return self._timesStartedAt != nil}
  /// Clears the value of `timesStartedAt`. Subsequent reads from it will return its default value.
  mutating func clearTimesStartedAt() {self._timesStartedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timesStartedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_RegisterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var password: String = String()

  var scope: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserAuthorizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var password: String = String()

  var responseType: String = String()

  var clientID: String = String()

  var redirectUri: String = String()

  var scope: String = String()

  var state: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String = String()

  var grantType: String = String()

  var refreshToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accessToken: String = String()

  var tokenType: String = String()

  var expiresIn: Int32 = 0

  var refreshToken: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _refreshToken ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_refreshToken = newValue}
  }
  /// Returns true if `refreshToken` has been explicitly set.
  var hasRefreshToken: Bool {return self._refreshToken != nil}
  /// Clears the value of `refreshToken`. Subsequent reads from it will return its default value.
  mutating func clearRefreshToken() {self._refreshToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _refreshToken: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

struct Api_UserRevokeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var refreshToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_UserAuthorizeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var code: String = String()

  var error: String = String()

  var state: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_RegisterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _success ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_success = newValue}
  }
  /// Returns true if `success` has been explicitly set.
  var hasSuccess: Bool {return self._success != nil}
  /// Clears the value of `success`. Subsequent reads from it will return its default value.
  mutating func clearSuccess() {self._success = nil}

  var message: String = String()

  var token: String = String()

  var uuid: String = String()

  var errors: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _success: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

struct Api_StarredEpisodesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var episodes: [Api_StarredEpisode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_StarredEpisode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var podcastUuid: String = String()

  var duration: Int32 = 0

  var playingStatus: Int32 = 0

  var playedUpTo: Int32 = 0

  var isDeleted: Bool = false

  var starredModified: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_PlaylistSyncResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._isDeleted ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._isDeleted = newValue}
  }
  /// Returns true if `isDeleted` has been explicitly set.
  var hasIsDeleted: Bool {return _storage._isDeleted != nil}
  /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
  mutating func clearIsDeleted() {_uniqueStorage()._isDeleted = nil}

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var audioVideo: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._audioVideo ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._audioVideo = newValue}
  }
  /// Returns true if `audioVideo` has been explicitly set.
  var hasAudioVideo: Bool {return _storage._audioVideo != nil}
  /// Clears the value of `audioVideo`. Subsequent reads from it will return its default value.
  mutating func clearAudioVideo() {_uniqueStorage()._audioVideo = nil}

  var notDownloaded: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._notDownloaded ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._notDownloaded = newValue}
  }
  /// Returns true if `notDownloaded` has been explicitly set.
  var hasNotDownloaded: Bool {return _storage._notDownloaded != nil}
  /// Clears the value of `notDownloaded`. Subsequent reads from it will return its default value.
  mutating func clearNotDownloaded() {_uniqueStorage()._notDownloaded = nil}

  var downloaded: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._downloaded ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._downloaded = newValue}
  }
  /// Returns true if `downloaded` has been explicitly set.
  var hasDownloaded: Bool {return _storage._downloaded != nil}
  /// Clears the value of `downloaded`. Subsequent reads from it will return its default value.
  mutating func clearDownloaded() {_uniqueStorage()._downloaded = nil}

  var downloading: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._downloading ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._downloading = newValue}
  }
  /// Returns true if `downloading` has been explicitly set.
  var hasDownloading: Bool {return _storage._downloading != nil}
  /// Clears the value of `downloading`. Subsequent reads from it will return its default value.
  mutating func clearDownloading() {_uniqueStorage()._downloading = nil}

  var finished: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._finished ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._finished = newValue}
  }
  /// Returns true if `finished` has been explicitly set.
  var hasFinished: Bool {return _storage._finished != nil}
  /// Clears the value of `finished`. Subsequent reads from it will return its default value.
  mutating func clearFinished() {_uniqueStorage()._finished = nil}

  var partiallyPlayed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._partiallyPlayed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._partiallyPlayed = newValue}
  }
  /// Returns true if `partiallyPlayed` has been explicitly set.
  var hasPartiallyPlayed: Bool {return _storage._partiallyPlayed != nil}
  /// Clears the value of `partiallyPlayed`. Subsequent reads from it will return its default value.
  mutating func clearPartiallyPlayed() {_uniqueStorage()._partiallyPlayed = nil}

  var unplayed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._unplayed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._unplayed = newValue}
  }
  /// Returns true if `unplayed` has been explicitly set.
  var hasUnplayed: Bool {return _storage._unplayed != nil}
  /// Clears the value of `unplayed`. Subsequent reads from it will return its default value.
  mutating func clearUnplayed() {_uniqueStorage()._unplayed = nil}

  var starred: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._starred ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._starred = newValue}
  }
  /// Returns true if `starred` has been explicitly set.
  var hasStarred: Bool {return _storage._starred != nil}
  /// Clears the value of `starred`. Subsequent reads from it will return its default value.
  mutating func clearStarred() {_uniqueStorage()._starred = nil}

  var manual: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._manual ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._manual = newValue}
  }
  /// Returns true if `manual` has been explicitly set.
  var hasManual: Bool {return _storage._manual != nil}
  /// Clears the value of `manual`. Subsequent reads from it will return its default value.
  mutating func clearManual() {_uniqueStorage()._manual = nil}

  var sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortPosition ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortPosition = newValue}
  }
  /// Returns true if `sortPosition` has been explicitly set.
  var hasSortPosition: Bool {return _storage._sortPosition != nil}
  /// Clears the value of `sortPosition`. Subsequent reads from it will return its default value.
  mutating func clearSortPosition() {_uniqueStorage()._sortPosition = nil}

  var sortType: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortType ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortType = newValue}
  }
  /// Returns true if `sortType` has been explicitly set.
  var hasSortType: Bool {return _storage._sortType != nil}
  /// Clears the value of `sortType`. Subsequent reads from it will return its default value.
  mutating func clearSortType() {_uniqueStorage()._sortType = nil}

  var iconID: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._iconID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._iconID = newValue}
  }
  /// Returns true if `iconID` has been explicitly set.
  var hasIconID: Bool {return _storage._iconID != nil}
  /// Clears the value of `iconID`. Subsequent reads from it will return its default value.
  mutating func clearIconID() {_uniqueStorage()._iconID = nil}

  var allPodcasts: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._allPodcasts ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._allPodcasts = newValue}
  }
  /// Returns true if `allPodcasts` has been explicitly set.
  var hasAllPodcasts: Bool {return _storage._allPodcasts != nil}
  /// Clears the value of `allPodcasts`. Subsequent reads from it will return its default value.
  mutating func clearAllPodcasts() {_uniqueStorage()._allPodcasts = nil}

  var filterHours: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._filterHours ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._filterHours = newValue}
  }
  /// Returns true if `filterHours` has been explicitly set.
  var hasFilterHours: Bool {return _storage._filterHours != nil}
  /// Clears the value of `filterHours`. Subsequent reads from it will return its default value.
  mutating func clearFilterHours() {_uniqueStorage()._filterHours = nil}

  var podcastUuids: String {
    get {return _storage._podcastUuids}
    set {_uniqueStorage()._podcastUuids = newValue}
  }

  var episodeUuids: String {
    get {return _storage._episodeUuids}
    set {_uniqueStorage()._episodeUuids = newValue}
  }

  var originalUuid: String {
    get {return _storage._originalUuid}
    set {_uniqueStorage()._originalUuid = newValue}
  }

  var filterDuration: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._filterDuration ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._filterDuration = newValue}
  }
  /// Returns true if `filterDuration` has been explicitly set.
  var hasFilterDuration: Bool {return _storage._filterDuration != nil}
  /// Clears the value of `filterDuration`. Subsequent reads from it will return its default value.
  mutating func clearFilterDuration() {_uniqueStorage()._filterDuration = nil}

  var longerThan: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._longerThan ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._longerThan = newValue}
  }
  /// Returns true if `longerThan` has been explicitly set.
  var hasLongerThan: Bool {return _storage._longerThan != nil}
  /// Clears the value of `longerThan`. Subsequent reads from it will return its default value.
  mutating func clearLongerThan() {_uniqueStorage()._longerThan = nil}

  var shorterThan: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._shorterThan ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._shorterThan = newValue}
  }
  /// Returns true if `shorterThan` has been explicitly set.
  var hasShorterThan: Bool {return _storage._shorterThan != nil}
  /// Clears the value of `shorterThan`. Subsequent reads from it will return its default value.
  mutating func clearShorterThan() {_uniqueStorage()._shorterThan = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_CheckEligibleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storeReceipt: Api_CheckEligibleRequest.OneOf_StoreReceipt? = nil

  var android: Api_SubscriptionsPurchaseAndroidRequest {
    get {
      if case .android(let v)? = storeReceipt {return v}
      return Api_SubscriptionsPurchaseAndroidRequest()
    }
    set {storeReceipt = .android(newValue)}
  }

  var apple: Api_SubscriptionsPurchaseAppleRequest {
    get {
      if case .apple(let v)? = storeReceipt {return v}
      return Api_SubscriptionsPurchaseAppleRequest()
    }
    set {storeReceipt = .apple(newValue)}
  }

  var web: Api_SubscriptionsPurchaseWebRequest {
    get {
      if case .web(let v)? = storeReceipt {return v}
      return Api_SubscriptionsPurchaseWebRequest()
    }
    set {storeReceipt = .web(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_StoreReceipt: Equatable {
    case android(Api_SubscriptionsPurchaseAndroidRequest)
    case apple(Api_SubscriptionsPurchaseAppleRequest)
    case web(Api_SubscriptionsPurchaseWebRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Api_CheckEligibleRequest.OneOf_StoreReceipt, rhs: Api_CheckEligibleRequest.OneOf_StoreReceipt) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.android, .android): return {
        guard case .android(let l) = lhs, case .android(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.apple, .apple): return {
        guard case .apple(let l) = lhs, case .apple(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.web, .web): return {
        guard case .web(let l) = lhs, case .web(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Api_CheckEligibleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var platform: Int32 = 0

  var eligible: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SubscriptionsPurchaseAndroidRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var purchaseToken: String = String()

  var sku: String = String()

  var newsletterOptIn: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SubscriptionsPurchaseAppleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var receipt: String = String()

  var newsletterOptIn: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SubscriptionsPurchaseWebRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var email: String = String()

  var paddleUserID: Int64 = 0

  var productID: String = String()

  var newsletterOptIn: Bool = false

  var subscriptionID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SubscriptionsWebStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var monthly: Int32 = 0

  var yearly: Int32 = 0

  var trial: Int32 = 0

  var webStatus: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SubscriptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var platform: Int32 {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  var type: Int32 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var frequency: Int32 {
    get {return _storage._frequency}
    set {_uniqueStorage()._frequency = newValue}
  }

  var autoRenewing: Bool {
    get {return _storage._autoRenewing}
    set {_uniqueStorage()._autoRenewing = newValue}
  }

  var expiryDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiryDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiryDate = newValue}
  }
  /// Returns true if `expiryDate` has been explicitly set.
  var hasExpiryDate: Bool {return _storage._expiryDate != nil}
  /// Clears the value of `expiryDate`. Subsequent reads from it will return its default value.
  mutating func clearExpiryDate() {_uniqueStorage()._expiryDate = nil}

  var cancelURL: String {
    get {return _storage._cancelURL}
    set {_uniqueStorage()._cancelURL = newValue}
  }

  var updateURL: String {
    get {return _storage._updateURL}
    set {_uniqueStorage()._updateURL = newValue}
  }

  var web: Api_SubscriptionsWebStatusResponse {
    get {return _storage._web ?? Api_SubscriptionsWebStatusResponse()}
    set {_uniqueStorage()._web = newValue}
  }
  /// Returns true if `web` has been explicitly set.
  var hasWeb: Bool {return _storage._web != nil}
  /// Clears the value of `web`. Subsequent reads from it will return its default value.
  mutating func clearWeb() {_uniqueStorage()._web = nil}

  var plan: String {
    get {return _storage._plan}
    set {_uniqueStorage()._plan = newValue}
  }

  var index: Int32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var giftDays: Int32 {
    get {return _storage._giftDays}
    set {_uniqueStorage()._giftDays = newValue}
  }

  var paid: Int32 {
    get {return _storage._paid}
    set {_uniqueStorage()._paid = newValue}
  }

  var webStatus: Int32 {
    get {return _storage._webStatus}
    set {_uniqueStorage()._webStatus = newValue}
  }

  var bundleUuid: String {
    get {return _storage._bundleUuid}
    set {_uniqueStorage()._bundleUuid = newValue}
  }

  var podcasts: [Api_PodcastPair] {
    get {return _storage._podcasts}
    set {_uniqueStorage()._podcasts = newValue}
  }

  var eligible: Bool {
    get {return _storage._eligible}
    set {_uniqueStorage()._eligible = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_PodcastPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var masterPodcastUuid: String = String()

  var userPodcastUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SubscriptionsStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paid: Int32 {
    get {return _storage._paid}
    set {_uniqueStorage()._paid = newValue}
  }

  var platform: Int32 {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  var expiryDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiryDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiryDate = newValue}
  }
  /// Returns true if `expiryDate` has been explicitly set.
  var hasExpiryDate: Bool {return _storage._expiryDate != nil}
  /// Clears the value of `expiryDate`. Subsequent reads from it will return its default value.
  mutating func clearExpiryDate() {_uniqueStorage()._expiryDate = nil}

  var autoRenewing: Bool {
    get {return _storage._autoRenewing}
    set {_uniqueStorage()._autoRenewing = newValue}
  }

  var giftDays: Int32 {
    get {return _storage._giftDays}
    set {_uniqueStorage()._giftDays = newValue}
  }

  var cancelURL: String {
    get {return _storage._cancelURL}
    set {_uniqueStorage()._cancelURL = newValue}
  }

  var updateURL: String {
    get {return _storage._updateURL}
    set {_uniqueStorage()._updateURL = newValue}
  }

  var frequency: Int32 {
    get {return _storage._frequency}
    set {_uniqueStorage()._frequency = newValue}
  }

  var web: Api_SubscriptionsWebStatusResponse {
    get {return _storage._web ?? Api_SubscriptionsWebStatusResponse()}
    set {_uniqueStorage()._web = newValue}
  }
  /// Returns true if `web` has been explicitly set.
  var hasWeb: Bool {return _storage._web != nil}
  /// Clears the value of `web`. Subsequent reads from it will return its default value.
  mutating func clearWeb() {_uniqueStorage()._web = nil}

  var subscriptions: [Api_SubscriptionResponse] {
    get {return _storage._subscriptions}
    set {_uniqueStorage()._subscriptions = newValue}
  }

  var type: Int32 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var index: Int32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  var webStatus: Int32 {
    get {return _storage._webStatus}
    set {_uniqueStorage()._webStatus = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_CancelUserSubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleUuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_LegacyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var device: String {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  var datetime: String {
    get {return _storage._datetime}
    set {_uniqueStorage()._datetime = newValue}
  }

  var v: String {
    get {return _storage._v}
    set {_uniqueStorage()._v = newValue}
  }

  var av: String {
    get {return _storage._av}
    set {_uniqueStorage()._av = newValue}
  }

  var ac: String {
    get {return _storage._ac}
    set {_uniqueStorage()._ac = newValue}
  }

  var h: String {
    get {return _storage._h}
    set {_uniqueStorage()._h = newValue}
  }

  var dt: String {
    get {return _storage._dt}
    set {_uniqueStorage()._dt = newValue}
  }

  var c: String {
    get {return _storage._c}
    set {_uniqueStorage()._c = newValue}
  }

  var l: String {
    get {return _storage._l}
    set {_uniqueStorage()._l = newValue}
  }

  var m: String {
    get {return _storage._m}
    set {_uniqueStorage()._m = newValue}
  }

  var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  var password: String {
    get {return _storage._password}
    set {_uniqueStorage()._password = newValue}
  }

  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var deviceUtcTimeMs: String {
    get {return _storage._deviceUtcTimeMs}
    set {_uniqueStorage()._deviceUtcTimeMs = newValue}
  }

  var data: String {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  var lastModified: String {
    get {return _storage._lastModified}
    set {_uniqueStorage()._lastModified = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_LegacyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: String = String()

  var token: String = String()

  var copyright: String = String()

  var result: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SyncUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceUtcTimeMs: Int64 = 0

  var lastModified: Int64 = 0

  var country: String = String()

  var deviceID: String = String()

  var records: [Api_Record] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SyncUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastModified: Int64 = 0

  var records: [Api_Record] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var record: Api_Record.OneOf_Record? = nil

  var podcast: Api_SyncUserPodcast {
    get {
      if case .podcast(let v)? = record {return v}
      return Api_SyncUserPodcast()
    }
    set {record = .podcast(newValue)}
  }

  var episode: Api_SyncUserEpisode {
    get {
      if case .episode(let v)? = record {return v}
      return Api_SyncUserEpisode()
    }
    set {record = .episode(newValue)}
  }

  var playlist: Api_SyncUserPlaylist {
    get {
      if case .playlist(let v)? = record {return v}
      return Api_SyncUserPlaylist()
    }
    set {record = .playlist(newValue)}
  }

  var device: Api_SyncUserDevice {
    get {
      if case .device(let v)? = record {return v}
      return Api_SyncUserDevice()
    }
    set {record = .device(newValue)}
  }

  var folder: Api_SyncUserFolder {
    get {
      if case .folder(let v)? = record {return v}
      return Api_SyncUserFolder()
    }
    set {record = .folder(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Record: Equatable {
    case podcast(Api_SyncUserPodcast)
    case episode(Api_SyncUserEpisode)
    case playlist(Api_SyncUserPlaylist)
    case device(Api_SyncUserDevice)
    case folder(Api_SyncUserFolder)

  #if !swift(>=4.1)
    static func ==(lhs: Api_Record.OneOf_Record, rhs: Api_Record.OneOf_Record) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.podcast, .podcast): return {
        guard case .podcast(let l) = lhs, case .podcast(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.episode, .episode): return {
        guard case .episode(let l) = lhs, case .episode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playlist, .playlist): return {
        guard case .playlist(let l) = lhs, case .playlist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.device, .device): return {
        guard case .device(let l) = lhs, case .device(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.folder, .folder): return {
        guard case .folder(let l) = lhs, case .folder(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Api_SyncUserPodcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _isDeleted ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_isDeleted = newValue}
  }
  /// Returns true if `isDeleted` has been explicitly set.
  var hasIsDeleted: Bool {return self._isDeleted != nil}
  /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
  mutating func clearIsDeleted() {self._isDeleted = nil}

  var subscribed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _subscribed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_subscribed = newValue}
  }
  /// Returns true if `subscribed` has been explicitly set.
  var hasSubscribed: Bool {return self._subscribed != nil}
  /// Clears the value of `subscribed`. Subsequent reads from it will return its default value.
  mutating func clearSubscribed() {self._subscribed = nil}

  var autoStartFrom: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _autoStartFrom ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_autoStartFrom = newValue}
  }
  /// Returns true if `autoStartFrom` has been explicitly set.
  var hasAutoStartFrom: Bool {return self._autoStartFrom != nil}
  /// Clears the value of `autoStartFrom`. Subsequent reads from it will return its default value.
  mutating func clearAutoStartFrom() {self._autoStartFrom = nil}

  var episodesSortOrder: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _episodesSortOrder ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_episodesSortOrder = newValue}
  }
  /// Returns true if `episodesSortOrder` has been explicitly set.
  var hasEpisodesSortOrder: Bool {return self._episodesSortOrder != nil}
  /// Clears the value of `episodesSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearEpisodesSortOrder() {self._episodesSortOrder = nil}

  var autoSkipLast: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _autoSkipLast ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_autoSkipLast = newValue}
  }
  /// Returns true if `autoSkipLast` has been explicitly set.
  var hasAutoSkipLast: Bool {return self._autoSkipLast != nil}
  /// Clears the value of `autoSkipLast`. Subsequent reads from it will return its default value.
  mutating func clearAutoSkipLast() {self._autoSkipLast = nil}

  var folderUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _folderUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_folderUuid = newValue}
  }
  /// Returns true if `folderUuid` has been explicitly set.
  var hasFolderUuid: Bool {return self._folderUuid != nil}
  /// Clears the value of `folderUuid`. Subsequent reads from it will return its default value.
  mutating func clearFolderUuid() {self._folderUuid = nil}

  var sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _sortPosition ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_sortPosition = newValue}
  }
  /// Returns true if `sortPosition` has been explicitly set.
  var hasSortPosition: Bool {return self._sortPosition != nil}
  /// Clears the value of `sortPosition`. Subsequent reads from it will return its default value.
  mutating func clearSortPosition() {self._sortPosition = nil}

  var dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateAdded ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateAdded = newValue}
  }
  /// Returns true if `dateAdded` has been explicitly set.
  var hasDateAdded: Bool {return self._dateAdded != nil}
  /// Clears the value of `dateAdded`. Subsequent reads from it will return its default value.
  mutating func clearDateAdded() {self._dateAdded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _subscribed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _autoStartFrom: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _episodesSortOrder: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _autoSkipLast: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _folderUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_SyncUserEpisode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var podcastUuid: String = String()

  var isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _isDeleted ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_isDeleted = newValue}
  }
  /// Returns true if `isDeleted` has been explicitly set.
  var hasIsDeleted: Bool {return self._isDeleted != nil}
  /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
  mutating func clearIsDeleted() {self._isDeleted = nil}

  var isDeletedModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _isDeletedModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_isDeletedModified = newValue}
  }
  /// Returns true if `isDeletedModified` has been explicitly set.
  var hasIsDeletedModified: Bool {return self._isDeletedModified != nil}
  /// Clears the value of `isDeletedModified`. Subsequent reads from it will return its default value.
  mutating func clearIsDeletedModified() {self._isDeletedModified = nil}

  var duration: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var durationModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _durationModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_durationModified = newValue}
  }
  /// Returns true if `durationModified` has been explicitly set.
  var hasDurationModified: Bool {return self._durationModified != nil}
  /// Clears the value of `durationModified`. Subsequent reads from it will return its default value.
  mutating func clearDurationModified() {self._durationModified = nil}

  var playingStatus: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _playingStatus ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_playingStatus = newValue}
  }
  /// Returns true if `playingStatus` has been explicitly set.
  var hasPlayingStatus: Bool {return self._playingStatus != nil}
  /// Clears the value of `playingStatus`. Subsequent reads from it will return its default value.
  mutating func clearPlayingStatus() {self._playingStatus = nil}

  var playingStatusModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _playingStatusModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_playingStatusModified = newValue}
  }
  /// Returns true if `playingStatusModified` has been explicitly set.
  var hasPlayingStatusModified: Bool {return self._playingStatusModified != nil}
  /// Clears the value of `playingStatusModified`. Subsequent reads from it will return its default value.
  mutating func clearPlayingStatusModified() {self._playingStatusModified = nil}

  var playedUpTo: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _playedUpTo ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_playedUpTo = newValue}
  }
  /// Returns true if `playedUpTo` has been explicitly set.
  var hasPlayedUpTo: Bool {return self._playedUpTo != nil}
  /// Clears the value of `playedUpTo`. Subsequent reads from it will return its default value.
  mutating func clearPlayedUpTo() {self._playedUpTo = nil}

  var playedUpToModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _playedUpToModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_playedUpToModified = newValue}
  }
  /// Returns true if `playedUpToModified` has been explicitly set.
  var hasPlayedUpToModified: Bool {return self._playedUpToModified != nil}
  /// Clears the value of `playedUpToModified`. Subsequent reads from it will return its default value.
  mutating func clearPlayedUpToModified() {self._playedUpToModified = nil}

  var starred: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _starred ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_starred = newValue}
  }
  /// Returns true if `starred` has been explicitly set.
  var hasStarred: Bool {return self._starred != nil}
  /// Clears the value of `starred`. Subsequent reads from it will return its default value.
  mutating func clearStarred() {self._starred = nil}

  var starredModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _starredModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_starredModified = newValue}
  }
  /// Returns true if `starredModified` has been explicitly set.
  var hasStarredModified: Bool {return self._starredModified != nil}
  /// Clears the value of `starredModified`. Subsequent reads from it will return its default value.
  mutating func clearStarredModified() {self._starredModified = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _isDeletedModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _durationModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _playingStatus: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _playingStatusModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _playedUpTo: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _playedUpToModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _starred: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _starredModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

struct Api_SyncUserDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _deviceID ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  var hasDeviceID: Bool {return self._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  mutating func clearDeviceID() {self._deviceID = nil}

  var deviceType: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _deviceType ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_deviceType = newValue}
  }
  /// Returns true if `deviceType` has been explicitly set.
  var hasDeviceType: Bool {return self._deviceType != nil}
  /// Clears the value of `deviceType`. Subsequent reads from it will return its default value.
  mutating func clearDeviceType() {self._deviceType = nil}

  /// times in seconds
  var timesStartedAt: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _timesStartedAt ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_timesStartedAt = newValue}
  }
  /// Returns true if `timesStartedAt` has been explicitly set.
  var hasTimesStartedAt: Bool {return self._timesStartedAt != nil}
  /// Clears the value of `timesStartedAt`. Subsequent reads from it will return its default value.
  mutating func clearTimesStartedAt() {self._timesStartedAt = nil}

  var timeSilenceRemoval: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _timeSilenceRemoval ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_timeSilenceRemoval = newValue}
  }
  /// Returns true if `timeSilenceRemoval` has been explicitly set.
  var hasTimeSilenceRemoval: Bool {return self._timeSilenceRemoval != nil}
  /// Clears the value of `timeSilenceRemoval`. Subsequent reads from it will return its default value.
  mutating func clearTimeSilenceRemoval() {self._timeSilenceRemoval = nil}

  var timeVariableSpeed: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _timeVariableSpeed ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_timeVariableSpeed = newValue}
  }
  /// Returns true if `timeVariableSpeed` has been explicitly set.
  var hasTimeVariableSpeed: Bool {return self._timeVariableSpeed != nil}
  /// Clears the value of `timeVariableSpeed`. Subsequent reads from it will return its default value.
  mutating func clearTimeVariableSpeed() {self._timeVariableSpeed = nil}

  var timeIntroSkipping: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _timeIntroSkipping ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_timeIntroSkipping = newValue}
  }
  /// Returns true if `timeIntroSkipping` has been explicitly set.
  var hasTimeIntroSkipping: Bool {return self._timeIntroSkipping != nil}
  /// Clears the value of `timeIntroSkipping`. Subsequent reads from it will return its default value.
  mutating func clearTimeIntroSkipping() {self._timeIntroSkipping = nil}

  var timeSkipping: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _timeSkipping ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_timeSkipping = newValue}
  }
  /// Returns true if `timeSkipping` has been explicitly set.
  var hasTimeSkipping: Bool {return self._timeSkipping != nil}
  /// Clears the value of `timeSkipping`. Subsequent reads from it will return its default value.
  mutating func clearTimeSkipping() {self._timeSkipping = nil}

  var timeListened: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _timeListened ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_timeListened = newValue}
  }
  /// Returns true if `timeListened` has been explicitly set.
  var hasTimeListened: Bool {return self._timeListened != nil}
  /// Clears the value of `timeListened`. Subsequent reads from it will return its default value.
  mutating func clearTimeListened() {self._timeListened = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceID: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _deviceType: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _timesStartedAt: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _timeSilenceRemoval: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _timeVariableSpeed: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _timeIntroSkipping: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _timeSkipping: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _timeListened: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

struct Api_SyncUserPlaylist {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._isDeleted ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._isDeleted = newValue}
  }
  /// Returns true if `isDeleted` has been explicitly set.
  var hasIsDeleted: Bool {return _storage._isDeleted != nil}
  /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
  mutating func clearIsDeleted() {_uniqueStorage()._isDeleted = nil}

  var title: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._title ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  var allPodcasts: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._allPodcasts ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._allPodcasts = newValue}
  }
  /// Returns true if `allPodcasts` has been explicitly set.
  var hasAllPodcasts: Bool {return _storage._allPodcasts != nil}
  /// Clears the value of `allPodcasts`. Subsequent reads from it will return its default value.
  mutating func clearAllPodcasts() {_uniqueStorage()._allPodcasts = nil}

  var podcastUuids: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._podcastUuids ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._podcastUuids = newValue}
  }
  /// Returns true if `podcastUuids` has been explicitly set.
  var hasPodcastUuids: Bool {return _storage._podcastUuids != nil}
  /// Clears the value of `podcastUuids`. Subsequent reads from it will return its default value.
  mutating func clearPodcastUuids() {_uniqueStorage()._podcastUuids = nil}

  var episodeUuids: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._episodeUuids ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._episodeUuids = newValue}
  }
  /// Returns true if `episodeUuids` has been explicitly set.
  var hasEpisodeUuids: Bool {return _storage._episodeUuids != nil}
  /// Clears the value of `episodeUuids`. Subsequent reads from it will return its default value.
  mutating func clearEpisodeUuids() {_uniqueStorage()._episodeUuids = nil}

  var audioVideo: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._audioVideo ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._audioVideo = newValue}
  }
  /// Returns true if `audioVideo` has been explicitly set.
  var hasAudioVideo: Bool {return _storage._audioVideo != nil}
  /// Clears the value of `audioVideo`. Subsequent reads from it will return its default value.
  mutating func clearAudioVideo() {_uniqueStorage()._audioVideo = nil}

  var notDownloaded: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._notDownloaded ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._notDownloaded = newValue}
  }
  /// Returns true if `notDownloaded` has been explicitly set.
  var hasNotDownloaded: Bool {return _storage._notDownloaded != nil}
  /// Clears the value of `notDownloaded`. Subsequent reads from it will return its default value.
  mutating func clearNotDownloaded() {_uniqueStorage()._notDownloaded = nil}

  var downloaded: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._downloaded ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._downloaded = newValue}
  }
  /// Returns true if `downloaded` has been explicitly set.
  var hasDownloaded: Bool {return _storage._downloaded != nil}
  /// Clears the value of `downloaded`. Subsequent reads from it will return its default value.
  mutating func clearDownloaded() {_uniqueStorage()._downloaded = nil}

  var downloading: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._downloading ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._downloading = newValue}
  }
  /// Returns true if `downloading` has been explicitly set.
  var hasDownloading: Bool {return _storage._downloading != nil}
  /// Clears the value of `downloading`. Subsequent reads from it will return its default value.
  mutating func clearDownloading() {_uniqueStorage()._downloading = nil}

  var finished: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._finished ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._finished = newValue}
  }
  /// Returns true if `finished` has been explicitly set.
  var hasFinished: Bool {return _storage._finished != nil}
  /// Clears the value of `finished`. Subsequent reads from it will return its default value.
  mutating func clearFinished() {_uniqueStorage()._finished = nil}

  var partiallyPlayed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._partiallyPlayed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._partiallyPlayed = newValue}
  }
  /// Returns true if `partiallyPlayed` has been explicitly set.
  var hasPartiallyPlayed: Bool {return _storage._partiallyPlayed != nil}
  /// Clears the value of `partiallyPlayed`. Subsequent reads from it will return its default value.
  mutating func clearPartiallyPlayed() {_uniqueStorage()._partiallyPlayed = nil}

  var unplayed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._unplayed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._unplayed = newValue}
  }
  /// Returns true if `unplayed` has been explicitly set.
  var hasUnplayed: Bool {return _storage._unplayed != nil}
  /// Clears the value of `unplayed`. Subsequent reads from it will return its default value.
  mutating func clearUnplayed() {_uniqueStorage()._unplayed = nil}

  var starred: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._starred ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._starred = newValue}
  }
  /// Returns true if `starred` has been explicitly set.
  var hasStarred: Bool {return _storage._starred != nil}
  /// Clears the value of `starred`. Subsequent reads from it will return its default value.
  mutating func clearStarred() {_uniqueStorage()._starred = nil}

  var manual: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._manual ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._manual = newValue}
  }
  /// Returns true if `manual` has been explicitly set.
  var hasManual: Bool {return _storage._manual != nil}
  /// Clears the value of `manual`. Subsequent reads from it will return its default value.
  mutating func clearManual() {_uniqueStorage()._manual = nil}

  var sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortPosition ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortPosition = newValue}
  }
  /// Returns true if `sortPosition` has been explicitly set.
  var hasSortPosition: Bool {return _storage._sortPosition != nil}
  /// Clears the value of `sortPosition`. Subsequent reads from it will return its default value.
  mutating func clearSortPosition() {_uniqueStorage()._sortPosition = nil}

  var sortType: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortType ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortType = newValue}
  }
  /// Returns true if `sortType` has been explicitly set.
  var hasSortType: Bool {return _storage._sortType != nil}
  /// Clears the value of `sortType`. Subsequent reads from it will return its default value.
  mutating func clearSortType() {_uniqueStorage()._sortType = nil}

  var iconID: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._iconID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._iconID = newValue}
  }
  /// Returns true if `iconID` has been explicitly set.
  var hasIconID: Bool {return _storage._iconID != nil}
  /// Clears the value of `iconID`. Subsequent reads from it will return its default value.
  mutating func clearIconID() {_uniqueStorage()._iconID = nil}

  var filterHours: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._filterHours ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._filterHours = newValue}
  }
  /// Returns true if `filterHours` has been explicitly set.
  var hasFilterHours: Bool {return _storage._filterHours != nil}
  /// Clears the value of `filterHours`. Subsequent reads from it will return its default value.
  mutating func clearFilterHours() {_uniqueStorage()._filterHours = nil}

  var originalUuid: String {
    get {return _storage._originalUuid}
    set {_uniqueStorage()._originalUuid = newValue}
  }

  var filterDuration: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._filterDuration ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._filterDuration = newValue}
  }
  /// Returns true if `filterDuration` has been explicitly set.
  var hasFilterDuration: Bool {return _storage._filterDuration != nil}
  /// Clears the value of `filterDuration`. Subsequent reads from it will return its default value.
  mutating func clearFilterDuration() {_uniqueStorage()._filterDuration = nil}

  var longerThan: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._longerThan ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._longerThan = newValue}
  }
  /// Returns true if `longerThan` has been explicitly set.
  var hasLongerThan: Bool {return _storage._longerThan != nil}
  /// Clears the value of `longerThan`. Subsequent reads from it will return its default value.
  mutating func clearLongerThan() {_uniqueStorage()._longerThan = nil}

  var shorterThan: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._shorterThan ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._shorterThan = newValue}
  }
  /// Returns true if `shorterThan` has been explicitly set.
  var hasShorterThan: Bool {return _storage._shorterThan != nil}
  /// Clears the value of `shorterThan`. Subsequent reads from it will return its default value.
  mutating func clearShorterThan() {_uniqueStorage()._shorterThan = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_SyncUserFolder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var folderUuid: String = String()

  var isDeleted: Bool = false

  var name: String = String()

  var color: Int32 = 0

  var sortPosition: Int32 = 0

  var podcastsSortType: Int32 = 0

  var dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateAdded ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateAdded = newValue}
  }
  /// Returns true if `dateAdded` has been explicitly set.
  var hasDateAdded: Bool {return self._dateAdded != nil}
  /// Clears the value of `dateAdded`. Subsequent reads from it will return its default value.
  mutating func clearDateAdded() {self._dateAdded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_LegacySyncData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var records: [Api_LegacySyncRecord] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_LegacySyncRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var fields: Api_LegacyRecord {
    get {return _fields ?? Api_LegacyRecord()}
    set {_fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  var hasFields: Bool {return self._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  mutating func clearFields() {self._fields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fields: Api_LegacyRecord? = nil
}

struct Api_LegacyRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._uuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var userPodcastUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._userPodcastUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._userPodcastUuid = newValue}
  }
  /// Returns true if `userPodcastUuid` has been explicitly set.
  var hasUserPodcastUuid: Bool {return _storage._userPodcastUuid != nil}
  /// Clears the value of `userPodcastUuid`. Subsequent reads from it will return its default value.
  mutating func clearUserPodcastUuid() {_uniqueStorage()._userPodcastUuid = nil}

  var episodeUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._episodeUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._episodeUuid = newValue}
  }
  /// Returns true if `episodeUuid` has been explicitly set.
  var hasEpisodeUuid: Bool {return _storage._episodeUuid != nil}
  /// Clears the value of `episodeUuid`. Subsequent reads from it will return its default value.
  mutating func clearEpisodeUuid() {_uniqueStorage()._episodeUuid = nil}

  var podcastUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._podcastUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._podcastUuid = newValue}
  }
  /// Returns true if `podcastUuid` has been explicitly set.
  var hasPodcastUuid: Bool {return _storage._podcastUuid != nil}
  /// Clears the value of `podcastUuid`. Subsequent reads from it will return its default value.
  mutating func clearPodcastUuid() {_uniqueStorage()._podcastUuid = nil}

  var isDeleted: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._isDeleted ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._isDeleted = newValue}
  }
  /// Returns true if `isDeleted` has been explicitly set.
  var hasIsDeleted: Bool {return _storage._isDeleted != nil}
  /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
  mutating func clearIsDeleted() {_uniqueStorage()._isDeleted = nil}

  var isDeletedModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._isDeletedModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._isDeletedModified = newValue}
  }
  /// Returns true if `isDeletedModified` has been explicitly set.
  var hasIsDeletedModified: Bool {return _storage._isDeletedModified != nil}
  /// Clears the value of `isDeletedModified`. Subsequent reads from it will return its default value.
  mutating func clearIsDeletedModified() {_uniqueStorage()._isDeletedModified = nil}

  var duration: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._duration ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {_uniqueStorage()._duration = nil}

  var durationModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._durationModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._durationModified = newValue}
  }
  /// Returns true if `durationModified` has been explicitly set.
  var hasDurationModified: Bool {return _storage._durationModified != nil}
  /// Clears the value of `durationModified`. Subsequent reads from it will return its default value.
  mutating func clearDurationModified() {_uniqueStorage()._durationModified = nil}

  var playingStatus: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._playingStatus ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._playingStatus = newValue}
  }
  /// Returns true if `playingStatus` has been explicitly set.
  var hasPlayingStatus: Bool {return _storage._playingStatus != nil}
  /// Clears the value of `playingStatus`. Subsequent reads from it will return its default value.
  mutating func clearPlayingStatus() {_uniqueStorage()._playingStatus = nil}

  var playingStatusModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._playingStatusModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._playingStatusModified = newValue}
  }
  /// Returns true if `playingStatusModified` has been explicitly set.
  var hasPlayingStatusModified: Bool {return _storage._playingStatusModified != nil}
  /// Clears the value of `playingStatusModified`. Subsequent reads from it will return its default value.
  mutating func clearPlayingStatusModified() {_uniqueStorage()._playingStatusModified = nil}

  var playedUpTo: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._playedUpTo ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._playedUpTo = newValue}
  }
  /// Returns true if `playedUpTo` has been explicitly set.
  var hasPlayedUpTo: Bool {return _storage._playedUpTo != nil}
  /// Clears the value of `playedUpTo`. Subsequent reads from it will return its default value.
  mutating func clearPlayedUpTo() {_uniqueStorage()._playedUpTo = nil}

  var playedUpToModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._playedUpToModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._playedUpToModified = newValue}
  }
  /// Returns true if `playedUpToModified` has been explicitly set.
  var hasPlayedUpToModified: Bool {return _storage._playedUpToModified != nil}
  /// Clears the value of `playedUpToModified`. Subsequent reads from it will return its default value.
  mutating func clearPlayedUpToModified() {_uniqueStorage()._playedUpToModified = nil}

  var starred: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._starred ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._starred = newValue}
  }
  /// Returns true if `starred` has been explicitly set.
  var hasStarred: Bool {return _storage._starred != nil}
  /// Clears the value of `starred`. Subsequent reads from it will return its default value.
  mutating func clearStarred() {_uniqueStorage()._starred = nil}

  var starredModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._starredModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._starredModified = newValue}
  }
  /// Returns true if `starredModified` has been explicitly set.
  var hasStarredModified: Bool {return _storage._starredModified != nil}
  /// Clears the value of `starredModified`. Subsequent reads from it will return its default value.
  mutating func clearStarredModified() {_uniqueStorage()._starredModified = nil}

  var timesStartedAt: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._timesStartedAt ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._timesStartedAt = newValue}
  }
  /// Returns true if `timesStartedAt` has been explicitly set.
  var hasTimesStartedAt: Bool {return _storage._timesStartedAt != nil}
  /// Clears the value of `timesStartedAt`. Subsequent reads from it will return its default value.
  mutating func clearTimesStartedAt() {_uniqueStorage()._timesStartedAt = nil}

  var timeSilenceRemoval: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._timeSilenceRemoval ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._timeSilenceRemoval = newValue}
  }
  /// Returns true if `timeSilenceRemoval` has been explicitly set.
  var hasTimeSilenceRemoval: Bool {return _storage._timeSilenceRemoval != nil}
  /// Clears the value of `timeSilenceRemoval`. Subsequent reads from it will return its default value.
  mutating func clearTimeSilenceRemoval() {_uniqueStorage()._timeSilenceRemoval = nil}

  var timeVariableSpeed: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._timeVariableSpeed ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._timeVariableSpeed = newValue}
  }
  /// Returns true if `timeVariableSpeed` has been explicitly set.
  var hasTimeVariableSpeed: Bool {return _storage._timeVariableSpeed != nil}
  /// Clears the value of `timeVariableSpeed`. Subsequent reads from it will return its default value.
  mutating func clearTimeVariableSpeed() {_uniqueStorage()._timeVariableSpeed = nil}

  var timeIntroSkipping: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._timeIntroSkipping ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._timeIntroSkipping = newValue}
  }
  /// Returns true if `timeIntroSkipping` has been explicitly set.
  var hasTimeIntroSkipping: Bool {return _storage._timeIntroSkipping != nil}
  /// Clears the value of `timeIntroSkipping`. Subsequent reads from it will return its default value.
  mutating func clearTimeIntroSkipping() {_uniqueStorage()._timeIntroSkipping = nil}

  var timeSkipping: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._timeSkipping ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._timeSkipping = newValue}
  }
  /// Returns true if `timeSkipping` has been explicitly set.
  var hasTimeSkipping: Bool {return _storage._timeSkipping != nil}
  /// Clears the value of `timeSkipping`. Subsequent reads from it will return its default value.
  mutating func clearTimeSkipping() {_uniqueStorage()._timeSkipping = nil}

  var timeListened: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._timeListened ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._timeListened = newValue}
  }
  /// Returns true if `timeListened` has been explicitly set.
  var hasTimeListened: Bool {return _storage._timeListened != nil}
  /// Clears the value of `timeListened`. Subsequent reads from it will return its default value.
  mutating func clearTimeListened() {_uniqueStorage()._timeListened = nil}

  var autoStartFrom: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._autoStartFrom ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._autoStartFrom = newValue}
  }
  /// Returns true if `autoStartFrom` has been explicitly set.
  var hasAutoStartFrom: Bool {return _storage._autoStartFrom != nil}
  /// Clears the value of `autoStartFrom`. Subsequent reads from it will return its default value.
  mutating func clearAutoStartFrom() {_uniqueStorage()._autoStartFrom = nil}

  var subscribed: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._subscribed ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._subscribed = newValue}
  }
  /// Returns true if `subscribed` has been explicitly set.
  var hasSubscribed: Bool {return _storage._subscribed != nil}
  /// Clears the value of `subscribed`. Subsequent reads from it will return its default value.
  mutating func clearSubscribed() {_uniqueStorage()._subscribed = nil}

  var title: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._title ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  /// then a heap of playlist fields
  var allPodcasts: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._allPodcasts ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._allPodcasts = newValue}
  }
  /// Returns true if `allPodcasts` has been explicitly set.
  var hasAllPodcasts: Bool {return _storage._allPodcasts != nil}
  /// Clears the value of `allPodcasts`. Subsequent reads from it will return its default value.
  mutating func clearAllPodcasts() {_uniqueStorage()._allPodcasts = nil}

  var podcastUuids: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._podcastUuids ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._podcastUuids = newValue}
  }
  /// Returns true if `podcastUuids` has been explicitly set.
  var hasPodcastUuids: Bool {return _storage._podcastUuids != nil}
  /// Clears the value of `podcastUuids`. Subsequent reads from it will return its default value.
  mutating func clearPodcastUuids() {_uniqueStorage()._podcastUuids = nil}

  var episodeUuids: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._episodeUuids ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._episodeUuids = newValue}
  }
  /// Returns true if `episodeUuids` has been explicitly set.
  var hasEpisodeUuids: Bool {return _storage._episodeUuids != nil}
  /// Clears the value of `episodeUuids`. Subsequent reads from it will return its default value.
  mutating func clearEpisodeUuids() {_uniqueStorage()._episodeUuids = nil}

  var audioVideo: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._audioVideo ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._audioVideo = newValue}
  }
  /// Returns true if `audioVideo` has been explicitly set.
  var hasAudioVideo: Bool {return _storage._audioVideo != nil}
  /// Clears the value of `audioVideo`. Subsequent reads from it will return its default value.
  mutating func clearAudioVideo() {_uniqueStorage()._audioVideo = nil}

  var notDownloaded: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._notDownloaded ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._notDownloaded = newValue}
  }
  /// Returns true if `notDownloaded` has been explicitly set.
  var hasNotDownloaded: Bool {return _storage._notDownloaded != nil}
  /// Clears the value of `notDownloaded`. Subsequent reads from it will return its default value.
  mutating func clearNotDownloaded() {_uniqueStorage()._notDownloaded = nil}

  var downloaded: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._downloaded ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._downloaded = newValue}
  }
  /// Returns true if `downloaded` has been explicitly set.
  var hasDownloaded: Bool {return _storage._downloaded != nil}
  /// Clears the value of `downloaded`. Subsequent reads from it will return its default value.
  mutating func clearDownloaded() {_uniqueStorage()._downloaded = nil}

  var downloading: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._downloading ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._downloading = newValue}
  }
  /// Returns true if `downloading` has been explicitly set.
  var hasDownloading: Bool {return _storage._downloading != nil}
  /// Clears the value of `downloading`. Subsequent reads from it will return its default value.
  mutating func clearDownloading() {_uniqueStorage()._downloading = nil}

  var finished: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._finished ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._finished = newValue}
  }
  /// Returns true if `finished` has been explicitly set.
  var hasFinished: Bool {return _storage._finished != nil}
  /// Clears the value of `finished`. Subsequent reads from it will return its default value.
  mutating func clearFinished() {_uniqueStorage()._finished = nil}

  var partiallyPlayed: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._partiallyPlayed ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._partiallyPlayed = newValue}
  }
  /// Returns true if `partiallyPlayed` has been explicitly set.
  var hasPartiallyPlayed: Bool {return _storage._partiallyPlayed != nil}
  /// Clears the value of `partiallyPlayed`. Subsequent reads from it will return its default value.
  mutating func clearPartiallyPlayed() {_uniqueStorage()._partiallyPlayed = nil}

  var unplayed: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._unplayed ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._unplayed = newValue}
  }
  /// Returns true if `unplayed` has been explicitly set.
  var hasUnplayed: Bool {return _storage._unplayed != nil}
  /// Clears the value of `unplayed`. Subsequent reads from it will return its default value.
  mutating func clearUnplayed() {_uniqueStorage()._unplayed = nil}

  var manual: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._manual ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._manual = newValue}
  }
  /// Returns true if `manual` has been explicitly set.
  var hasManual: Bool {return _storage._manual != nil}
  /// Clears the value of `manual`. Subsequent reads from it will return its default value.
  mutating func clearManual() {_uniqueStorage()._manual = nil}

  var sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortPosition ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortPosition = newValue}
  }
  /// Returns true if `sortPosition` has been explicitly set.
  var hasSortPosition: Bool {return _storage._sortPosition != nil}
  /// Clears the value of `sortPosition`. Subsequent reads from it will return its default value.
  mutating func clearSortPosition() {_uniqueStorage()._sortPosition = nil}

  var sortType: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortType ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortType = newValue}
  }
  /// Returns true if `sortType` has been explicitly set.
  var hasSortType: Bool {return _storage._sortType != nil}
  /// Clears the value of `sortType`. Subsequent reads from it will return its default value.
  mutating func clearSortType() {_uniqueStorage()._sortType = nil}

  var iconID: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._iconID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._iconID = newValue}
  }
  /// Returns true if `iconID` has been explicitly set.
  var hasIconID: Bool {return _storage._iconID != nil}
  /// Clears the value of `iconID`. Subsequent reads from it will return its default value.
  mutating func clearIconID() {_uniqueStorage()._iconID = nil}

  var filterHours: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._filterHours ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._filterHours = newValue}
  }
  /// Returns true if `filterHours` has been explicitly set.
  var hasFilterHours: Bool {return _storage._filterHours != nil}
  /// Clears the value of `filterHours`. Subsequent reads from it will return its default value.
  mutating func clearFilterHours() {_uniqueStorage()._filterHours = nil}

  /// new fields
  var autoSkipLast: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._autoSkipLast ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._autoSkipLast = newValue}
  }
  /// Returns true if `autoSkipLast` has been explicitly set.
  var hasAutoSkipLast: Bool {return _storage._autoSkipLast != nil}
  /// Clears the value of `autoSkipLast`. Subsequent reads from it will return its default value.
  mutating func clearAutoSkipLast() {_uniqueStorage()._autoSkipLast = nil}

  /// episode duration filters
  var filterDuration: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._filterDuration ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._filterDuration = newValue}
  }
  /// Returns true if `filterDuration` has been explicitly set.
  var hasFilterDuration: Bool {return _storage._filterDuration != nil}
  /// Clears the value of `filterDuration`. Subsequent reads from it will return its default value.
  mutating func clearFilterDuration() {_uniqueStorage()._filterDuration = nil}

  var longerThan: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._longerThan ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._longerThan = newValue}
  }
  /// Returns true if `longerThan` has been explicitly set.
  var hasLongerThan: Bool {return _storage._longerThan != nil}
  /// Clears the value of `longerThan`. Subsequent reads from it will return its default value.
  mutating func clearLongerThan() {_uniqueStorage()._longerThan = nil}

  var shorterThan: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._shorterThan ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._shorterThan = newValue}
  }
  /// Returns true if `shorterThan` has been explicitly set.
  var hasShorterThan: Bool {return _storage._shorterThan != nil}
  /// Clears the value of `shorterThan`. Subsequent reads from it will return its default value.
  mutating func clearShorterThan() {_uniqueStorage()._shorterThan = nil}

  /// folder fields
  var folderUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._folderUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._folderUuid = newValue}
  }
  /// Returns true if `folderUuid` has been explicitly set.
  var hasFolderUuid: Bool {return _storage._folderUuid != nil}
  /// Clears the value of `folderUuid`. Subsequent reads from it will return its default value.
  mutating func clearFolderUuid() {_uniqueStorage()._folderUuid = nil}

  var name: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._name ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var color: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._color ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var podcastsSortType: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._podcastsSortType ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._podcastsSortType = newValue}
  }
  /// Returns true if `podcastsSortType` has been explicitly set.
  var hasPodcastsSortType: Bool {return _storage._podcastsSortType != nil}
  /// Clears the value of `podcastsSortType`. Subsequent reads from it will return its default value.
  mutating func clearPodcastsSortType() {_uniqueStorage()._podcastsSortType = nil}

  var dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateAdded ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateAdded = newValue}
  }
  /// Returns true if `dateAdded` has been explicitly set.
  var hasDateAdded: Bool {return _storage._dateAdded != nil}
  /// Clears the value of `dateAdded`. Subsequent reads from it will return its default value.
  mutating func clearDateAdded() {_uniqueStorage()._dateAdded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_LegacySyncResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastModified: String = String()

  var changes: [Api_LegacySyncResponseRecord] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_LegacySyncResponseRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var fields: Api_LegacyResponseRecord {
    get {return _fields ?? Api_LegacyResponseRecord()}
    set {_fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  var hasFields: Bool {return self._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  mutating func clearFields() {self._fields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fields: Api_LegacyResponseRecord? = nil
}

struct Api_LegacyResponseRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._uuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var userPodcastUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._userPodcastUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._userPodcastUuid = newValue}
  }
  /// Returns true if `userPodcastUuid` has been explicitly set.
  var hasUserPodcastUuid: Bool {return _storage._userPodcastUuid != nil}
  /// Clears the value of `userPodcastUuid`. Subsequent reads from it will return its default value.
  mutating func clearUserPodcastUuid() {_uniqueStorage()._userPodcastUuid = nil}

  var episodeUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._episodeUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._episodeUuid = newValue}
  }
  /// Returns true if `episodeUuid` has been explicitly set.
  var hasEpisodeUuid: Bool {return _storage._episodeUuid != nil}
  /// Clears the value of `episodeUuid`. Subsequent reads from it will return its default value.
  mutating func clearEpisodeUuid() {_uniqueStorage()._episodeUuid = nil}

  var podcastUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._podcastUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._podcastUuid = newValue}
  }
  /// Returns true if `podcastUuid` has been explicitly set.
  var hasPodcastUuid: Bool {return _storage._podcastUuid != nil}
  /// Clears the value of `podcastUuid`. Subsequent reads from it will return its default value.
  mutating func clearPodcastUuid() {_uniqueStorage()._podcastUuid = nil}

  var isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._isDeleted ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._isDeleted = newValue}
  }
  /// Returns true if `isDeleted` has been explicitly set.
  var hasIsDeleted: Bool {return _storage._isDeleted != nil}
  /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
  mutating func clearIsDeleted() {_uniqueStorage()._isDeleted = nil}

  var isDeletedModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._isDeletedModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._isDeletedModified = newValue}
  }
  /// Returns true if `isDeletedModified` has been explicitly set.
  var hasIsDeletedModified: Bool {return _storage._isDeletedModified != nil}
  /// Clears the value of `isDeletedModified`. Subsequent reads from it will return its default value.
  mutating func clearIsDeletedModified() {_uniqueStorage()._isDeletedModified = nil}

  var duration: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._duration ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {_uniqueStorage()._duration = nil}

  var durationModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._durationModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._durationModified = newValue}
  }
  /// Returns true if `durationModified` has been explicitly set.
  var hasDurationModified: Bool {return _storage._durationModified != nil}
  /// Clears the value of `durationModified`. Subsequent reads from it will return its default value.
  mutating func clearDurationModified() {_uniqueStorage()._durationModified = nil}

  var playingStatus: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._playingStatus ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._playingStatus = newValue}
  }
  /// Returns true if `playingStatus` has been explicitly set.
  var hasPlayingStatus: Bool {return _storage._playingStatus != nil}
  /// Clears the value of `playingStatus`. Subsequent reads from it will return its default value.
  mutating func clearPlayingStatus() {_uniqueStorage()._playingStatus = nil}

  var playingStatusModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._playingStatusModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._playingStatusModified = newValue}
  }
  /// Returns true if `playingStatusModified` has been explicitly set.
  var hasPlayingStatusModified: Bool {return _storage._playingStatusModified != nil}
  /// Clears the value of `playingStatusModified`. Subsequent reads from it will return its default value.
  mutating func clearPlayingStatusModified() {_uniqueStorage()._playingStatusModified = nil}

  var playedUpTo: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _storage._playedUpTo ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_uniqueStorage()._playedUpTo = newValue}
  }
  /// Returns true if `playedUpTo` has been explicitly set.
  var hasPlayedUpTo: Bool {return _storage._playedUpTo != nil}
  /// Clears the value of `playedUpTo`. Subsequent reads from it will return its default value.
  mutating func clearPlayedUpTo() {_uniqueStorage()._playedUpTo = nil}

  var playedUpToModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._playedUpToModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._playedUpToModified = newValue}
  }
  /// Returns true if `playedUpToModified` has been explicitly set.
  var hasPlayedUpToModified: Bool {return _storage._playedUpToModified != nil}
  /// Clears the value of `playedUpToModified`. Subsequent reads from it will return its default value.
  mutating func clearPlayedUpToModified() {_uniqueStorage()._playedUpToModified = nil}

  var starred: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._starred ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._starred = newValue}
  }
  /// Returns true if `starred` has been explicitly set.
  var hasStarred: Bool {return _storage._starred != nil}
  /// Clears the value of `starred`. Subsequent reads from it will return its default value.
  mutating func clearStarred() {_uniqueStorage()._starred = nil}

  var starredModified: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._starredModified ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._starredModified = newValue}
  }
  /// Returns true if `starredModified` has been explicitly set.
  var hasStarredModified: Bool {return _storage._starredModified != nil}
  /// Clears the value of `starredModified`. Subsequent reads from it will return its default value.
  mutating func clearStarredModified() {_uniqueStorage()._starredModified = nil}

  var timesStartedAt: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._timesStartedAt ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._timesStartedAt = newValue}
  }
  /// Returns true if `timesStartedAt` has been explicitly set.
  var hasTimesStartedAt: Bool {return _storage._timesStartedAt != nil}
  /// Clears the value of `timesStartedAt`. Subsequent reads from it will return its default value.
  mutating func clearTimesStartedAt() {_uniqueStorage()._timesStartedAt = nil}

  var timeSilenceRemoval: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._timeSilenceRemoval ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._timeSilenceRemoval = newValue}
  }
  /// Returns true if `timeSilenceRemoval` has been explicitly set.
  var hasTimeSilenceRemoval: Bool {return _storage._timeSilenceRemoval != nil}
  /// Clears the value of `timeSilenceRemoval`. Subsequent reads from it will return its default value.
  mutating func clearTimeSilenceRemoval() {_uniqueStorage()._timeSilenceRemoval = nil}

  var timeVariableSpeed: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._timeVariableSpeed ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._timeVariableSpeed = newValue}
  }
  /// Returns true if `timeVariableSpeed` has been explicitly set.
  var hasTimeVariableSpeed: Bool {return _storage._timeVariableSpeed != nil}
  /// Clears the value of `timeVariableSpeed`. Subsequent reads from it will return its default value.
  mutating func clearTimeVariableSpeed() {_uniqueStorage()._timeVariableSpeed = nil}

  var timeIntroSkipping: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._timeIntroSkipping ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._timeIntroSkipping = newValue}
  }
  /// Returns true if `timeIntroSkipping` has been explicitly set.
  var hasTimeIntroSkipping: Bool {return _storage._timeIntroSkipping != nil}
  /// Clears the value of `timeIntroSkipping`. Subsequent reads from it will return its default value.
  mutating func clearTimeIntroSkipping() {_uniqueStorage()._timeIntroSkipping = nil}

  var timeSkipping: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._timeSkipping ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._timeSkipping = newValue}
  }
  /// Returns true if `timeSkipping` has been explicitly set.
  var hasTimeSkipping: Bool {return _storage._timeSkipping != nil}
  /// Clears the value of `timeSkipping`. Subsequent reads from it will return its default value.
  mutating func clearTimeSkipping() {_uniqueStorage()._timeSkipping = nil}

  var timeListened: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._timeListened ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._timeListened = newValue}
  }
  /// Returns true if `timeListened` has been explicitly set.
  var hasTimeListened: Bool {return _storage._timeListened != nil}
  /// Clears the value of `timeListened`. Subsequent reads from it will return its default value.
  mutating func clearTimeListened() {_uniqueStorage()._timeListened = nil}

  var autoStartFrom: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._autoStartFrom ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._autoStartFrom = newValue}
  }
  /// Returns true if `autoStartFrom` has been explicitly set.
  var hasAutoStartFrom: Bool {return _storage._autoStartFrom != nil}
  /// Clears the value of `autoStartFrom`. Subsequent reads from it will return its default value.
  mutating func clearAutoStartFrom() {_uniqueStorage()._autoStartFrom = nil}

  var subscribed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._subscribed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._subscribed = newValue}
  }
  /// Returns true if `subscribed` has been explicitly set.
  var hasSubscribed: Bool {return _storage._subscribed != nil}
  /// Clears the value of `subscribed`. Subsequent reads from it will return its default value.
  mutating func clearSubscribed() {_uniqueStorage()._subscribed = nil}

  var title: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._title ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  /// then a heap of playlist fields
  var allPodcasts: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._allPodcasts ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._allPodcasts = newValue}
  }
  /// Returns true if `allPodcasts` has been explicitly set.
  var hasAllPodcasts: Bool {return _storage._allPodcasts != nil}
  /// Clears the value of `allPodcasts`. Subsequent reads from it will return its default value.
  mutating func clearAllPodcasts() {_uniqueStorage()._allPodcasts = nil}

  var podcastUuids: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._podcastUuids ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._podcastUuids = newValue}
  }
  /// Returns true if `podcastUuids` has been explicitly set.
  var hasPodcastUuids: Bool {return _storage._podcastUuids != nil}
  /// Clears the value of `podcastUuids`. Subsequent reads from it will return its default value.
  mutating func clearPodcastUuids() {_uniqueStorage()._podcastUuids = nil}

  var episodeUuids: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._episodeUuids ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._episodeUuids = newValue}
  }
  /// Returns true if `episodeUuids` has been explicitly set.
  var hasEpisodeUuids: Bool {return _storage._episodeUuids != nil}
  /// Clears the value of `episodeUuids`. Subsequent reads from it will return its default value.
  mutating func clearEpisodeUuids() {_uniqueStorage()._episodeUuids = nil}

  var audioVideo: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._audioVideo ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._audioVideo = newValue}
  }
  /// Returns true if `audioVideo` has been explicitly set.
  var hasAudioVideo: Bool {return _storage._audioVideo != nil}
  /// Clears the value of `audioVideo`. Subsequent reads from it will return its default value.
  mutating func clearAudioVideo() {_uniqueStorage()._audioVideo = nil}

  var notDownloaded: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._notDownloaded ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._notDownloaded = newValue}
  }
  /// Returns true if `notDownloaded` has been explicitly set.
  var hasNotDownloaded: Bool {return _storage._notDownloaded != nil}
  /// Clears the value of `notDownloaded`. Subsequent reads from it will return its default value.
  mutating func clearNotDownloaded() {_uniqueStorage()._notDownloaded = nil}

  var downloaded: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._downloaded ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._downloaded = newValue}
  }
  /// Returns true if `downloaded` has been explicitly set.
  var hasDownloaded: Bool {return _storage._downloaded != nil}
  /// Clears the value of `downloaded`. Subsequent reads from it will return its default value.
  mutating func clearDownloaded() {_uniqueStorage()._downloaded = nil}

  var downloading: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._downloading ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._downloading = newValue}
  }
  /// Returns true if `downloading` has been explicitly set.
  var hasDownloading: Bool {return _storage._downloading != nil}
  /// Clears the value of `downloading`. Subsequent reads from it will return its default value.
  mutating func clearDownloading() {_uniqueStorage()._downloading = nil}

  var finished: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._finished ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._finished = newValue}
  }
  /// Returns true if `finished` has been explicitly set.
  var hasFinished: Bool {return _storage._finished != nil}
  /// Clears the value of `finished`. Subsequent reads from it will return its default value.
  mutating func clearFinished() {_uniqueStorage()._finished = nil}

  var partiallyPlayed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._partiallyPlayed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._partiallyPlayed = newValue}
  }
  /// Returns true if `partiallyPlayed` has been explicitly set.
  var hasPartiallyPlayed: Bool {return _storage._partiallyPlayed != nil}
  /// Clears the value of `partiallyPlayed`. Subsequent reads from it will return its default value.
  mutating func clearPartiallyPlayed() {_uniqueStorage()._partiallyPlayed = nil}

  var unplayed: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._unplayed ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._unplayed = newValue}
  }
  /// Returns true if `unplayed` has been explicitly set.
  var hasUnplayed: Bool {return _storage._unplayed != nil}
  /// Clears the value of `unplayed`. Subsequent reads from it will return its default value.
  mutating func clearUnplayed() {_uniqueStorage()._unplayed = nil}

  var manual: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._manual ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._manual = newValue}
  }
  /// Returns true if `manual` has been explicitly set.
  var hasManual: Bool {return _storage._manual != nil}
  /// Clears the value of `manual`. Subsequent reads from it will return its default value.
  mutating func clearManual() {_uniqueStorage()._manual = nil}

  var sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortPosition ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortPosition = newValue}
  }
  /// Returns true if `sortPosition` has been explicitly set.
  var hasSortPosition: Bool {return _storage._sortPosition != nil}
  /// Clears the value of `sortPosition`. Subsequent reads from it will return its default value.
  mutating func clearSortPosition() {_uniqueStorage()._sortPosition = nil}

  var sortType: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._sortType ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._sortType = newValue}
  }
  /// Returns true if `sortType` has been explicitly set.
  var hasSortType: Bool {return _storage._sortType != nil}
  /// Clears the value of `sortType`. Subsequent reads from it will return its default value.
  mutating func clearSortType() {_uniqueStorage()._sortType = nil}

  var iconID: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._iconID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._iconID = newValue}
  }
  /// Returns true if `iconID` has been explicitly set.
  var hasIconID: Bool {return _storage._iconID != nil}
  /// Clears the value of `iconID`. Subsequent reads from it will return its default value.
  mutating func clearIconID() {_uniqueStorage()._iconID = nil}

  var filterHours: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._filterHours ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._filterHours = newValue}
  }
  /// Returns true if `filterHours` has been explicitly set.
  var hasFilterHours: Bool {return _storage._filterHours != nil}
  /// Clears the value of `filterHours`. Subsequent reads from it will return its default value.
  mutating func clearFilterHours() {_uniqueStorage()._filterHours = nil}

  /// new fields
  var autoSkipLast: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._autoSkipLast ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._autoSkipLast = newValue}
  }
  /// Returns true if `autoSkipLast` has been explicitly set.
  var hasAutoSkipLast: Bool {return _storage._autoSkipLast != nil}
  /// Clears the value of `autoSkipLast`. Subsequent reads from it will return its default value.
  mutating func clearAutoSkipLast() {_uniqueStorage()._autoSkipLast = nil}

  var filterDuration: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._filterDuration ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._filterDuration = newValue}
  }
  /// Returns true if `filterDuration` has been explicitly set.
  var hasFilterDuration: Bool {return _storage._filterDuration != nil}
  /// Clears the value of `filterDuration`. Subsequent reads from it will return its default value.
  mutating func clearFilterDuration() {_uniqueStorage()._filterDuration = nil}

  var longerThan: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._longerThan ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._longerThan = newValue}
  }
  /// Returns true if `longerThan` has been explicitly set.
  var hasLongerThan: Bool {return _storage._longerThan != nil}
  /// Clears the value of `longerThan`. Subsequent reads from it will return its default value.
  mutating func clearLongerThan() {_uniqueStorage()._longerThan = nil}

  var shorterThan: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._shorterThan ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._shorterThan = newValue}
  }
  /// Returns true if `shorterThan` has been explicitly set.
  var hasShorterThan: Bool {return _storage._shorterThan != nil}
  /// Clears the value of `shorterThan`. Subsequent reads from it will return its default value.
  mutating func clearShorterThan() {_uniqueStorage()._shorterThan = nil}

  /// folder fields
  var folderUuid: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._folderUuid ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._folderUuid = newValue}
  }
  /// Returns true if `folderUuid` has been explicitly set.
  var hasFolderUuid: Bool {return _storage._folderUuid != nil}
  /// Clears the value of `folderUuid`. Subsequent reads from it will return its default value.
  mutating func clearFolderUuid() {_uniqueStorage()._folderUuid = nil}

  var name: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._name ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var color: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._color ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var podcastsSortType: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._podcastsSortType ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._podcastsSortType = newValue}
  }
  /// Returns true if `podcastsSortType` has been explicitly set.
  var hasPodcastsSortType: Bool {return _storage._podcastsSortType != nil}
  /// Clears the value of `podcastsSortType`. Subsequent reads from it will return its default value.
  mutating func clearPodcastsSortType() {_uniqueStorage()._podcastsSortType = nil}

  var dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateAdded ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateAdded = newValue}
  }
  /// Returns true if `dateAdded` has been explicitly set.
  var hasDateAdded: Bool {return _storage._dateAdded != nil}
  /// Clears the value of `dateAdded`. Subsequent reads from it will return its default value.
  mutating func clearDateAdded() {_uniqueStorage()._dateAdded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_LegacyStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timesStartedAt: Int32 = 0

  var timeSilenceRemoval: Int32 = 0

  var timeVariableSpeed: Int32 = 0

  var timeIntroSkipping: Int32 = 0

  var timeSkipping: Int32 = 0

  var timeListened: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_PromotionCode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_Promotion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String = String()

  var description_p: String = String()

  var startsAt: String = String()

  var endsAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_PodcastSubscriptionCheckRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userUuid: String = String()

  var podcastUuid: String = String()

  var platform: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_BundleUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userUuid: String = String()

  var bundles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_BundleUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userExists: Bool = false

  var paid: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_PodcastSubscriptionCheckResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paid: Bool = false

  var userExists: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_PodcastFolderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var model: String = String()

  var folder: Api_PodcastFolder {
    get {return _folder ?? Api_PodcastFolder()}
    set {_folder = newValue}
  }
  /// Returns true if `folder` has been explicitly set.
  var hasFolder: Bool {return self._folder != nil}
  /// Clears the value of `folder`. Subsequent reads from it will return its default value.
  mutating func clearFolder() {self._folder = nil}

  var podcasts: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _folder: Api_PodcastFolder? = nil
}

struct Api_PodcastFolder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var folderUuid: String = String()

  var name: String = String()

  var color: Int32 = 0

  var sortPosition: Int32 = 0

  var podcastsSortType: Int32 = 0

  var dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dateAdded ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dateAdded = newValue}
  }
  /// Returns true if `dateAdded` has been explicitly set.
  var hasDateAdded: Bool {return self._dateAdded != nil}
  /// Clears the value of `dateAdded`. Subsequent reads from it will return its default value.
  mutating func clearDateAdded() {self._dateAdded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_PodcastFolderSortRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var model: String = String()

  var podcasts: [Api_PodcastFolderSorting] = []

  var folders: [Api_PodcastFolderSorting] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_PodcastFolderSorting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var position: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_UserChangeResponse: @unchecked Sendable {}
extension Api_UserResetPasswordRequest: @unchecked Sendable {}
extension Api_EmailRequest: @unchecked Sendable {}
extension Api_UserChangeEmailRequest: @unchecked Sendable {}
extension Api_UserChangePasswordRequest: @unchecked Sendable {}
extension Api_EmptyRequest: @unchecked Sendable {}
extension Api_EmptyResponse: @unchecked Sendable {}
extension Api_SupportFeedbackRequest: @unchecked Sendable {}
extension Api_CreateBetaUserRequest: @unchecked Sendable {}
extension Api_UserLoginRequest: @unchecked Sendable {}
extension Api_UserLoginResponse: @unchecked Sendable {}
extension Api_BasicRequest: @unchecked Sendable {}
extension Api_UserIdResponse: @unchecked Sendable {}
extension Api_UserPlaylistEpisodesRequest: @unchecked Sendable {}
extension Api_UserPlaylistListRequest: @unchecked Sendable {}
extension Api_UserPodcastListRequest: @unchecked Sendable {}
extension Api_NamedSettingsRequest: @unchecked Sendable {}
extension Api_NamedSettings: @unchecked Sendable {}
extension Api_NamedSettingsResponse: @unchecked Sendable {}
extension Api_Int32Setting: @unchecked Sendable {}
extension Api_BoolSetting: @unchecked Sendable {}
extension Api_StringSetting: @unchecked Sendable {}
extension Api_DoubleSetting: @unchecked Sendable {}
extension Api_ApiPodcastResponse: @unchecked Sendable {}
extension Api_ApiPodcastListResponse: @unchecked Sendable {}
extension Api_UserPodcastResponse: @unchecked Sendable {}
extension Api_UserPlaylistListResponse: @unchecked Sendable {}
extension Api_UserPodcastListResponse: @unchecked Sendable {}
extension Api_UserLastSyncAtResponse: @unchecked Sendable {}
extension Api_UuidRequest: @unchecked Sendable {}
extension Api_KeywordRequest: @unchecked Sendable {}
extension Api_SyncEpisodesResponse: @unchecked Sendable {}
extension Api_FindUserEpisodesRequest: @unchecked Sendable {}
extension Api_EpisodesResponse: @unchecked Sendable {}
extension Api_FindUserEpisodeRequest: @unchecked Sendable {}
extension Api_EpisodeResponse: @unchecked Sendable {}
extension Api_SyncUpdateEpisodeResponse: @unchecked Sendable {}
extension Api_UpdateEpisodeRequest: @unchecked Sendable {}
extension Api_UpdateEpisodeResponse: @unchecked Sendable {}
extension Api_StatsRequest: @unchecked Sendable {}
extension Api_UpdateEpisodeStarRequest: @unchecked Sendable {}
extension Api_UpdateEpisodeStarResponse: @unchecked Sendable {}
extension Api_EpisodeWithPodcast: @unchecked Sendable {}
extension Api_UpdateEpisodesArchiveRequest: @unchecked Sendable {}
extension Api_UpNextSyncRequest: @unchecked Sendable {}
extension Api_UpNextPlayRequest: @unchecked Sendable {}
extension Api_UpNextListRequest: @unchecked Sendable {}
extension Api_UpNextEpisodeRequest: @unchecked Sendable {}
extension Api_UpNextChanges: @unchecked Sendable {}
extension Api_UpNextChanges.Change: @unchecked Sendable {}
extension Api_UpNextResponse: @unchecked Sendable {}
extension Api_UpNextResponse.EpisodeResponse: @unchecked Sendable {}
extension Api_UpNextResponse.EpisodeSyncResponse: @unchecked Sendable {}
extension Api_HistoryChange: @unchecked Sendable {}
extension Api_HistorySyncRequest: @unchecked Sendable {}
extension Api_HistoryResponse: @unchecked Sendable {}
extension Api_UpNextRemoveRequest: @unchecked Sendable {}
extension Api_EpisodeSyncResponse: @unchecked Sendable {}
extension Api_SearchPodcastsRequest: @unchecked Sendable {}
extension Api_HealthResponse: @unchecked Sendable {}
extension Api_StatsResponse: @unchecked Sendable {}
extension Api_RegisterRequest: @unchecked Sendable {}
extension Api_UserAuthorizeRequest: @unchecked Sendable {}
extension Api_UserTokenRequest: @unchecked Sendable {}
extension Api_UserTokenResponse: @unchecked Sendable {}
extension Api_UserRevokeRequest: @unchecked Sendable {}
extension Api_UserAuthorizeResponse: @unchecked Sendable {}
extension Api_RegisterResponse: @unchecked Sendable {}
extension Api_StarredEpisodesResponse: @unchecked Sendable {}
extension Api_StarredEpisode: @unchecked Sendable {}
extension Api_PlaylistSyncResponse: @unchecked Sendable {}
extension Api_CheckEligibleRequest: @unchecked Sendable {}
extension Api_CheckEligibleRequest.OneOf_StoreReceipt: @unchecked Sendable {}
extension Api_CheckEligibleResponse: @unchecked Sendable {}
extension Api_SubscriptionsPurchaseAndroidRequest: @unchecked Sendable {}
extension Api_SubscriptionsPurchaseAppleRequest: @unchecked Sendable {}
extension Api_SubscriptionsPurchaseWebRequest: @unchecked Sendable {}
extension Api_SubscriptionsWebStatusResponse: @unchecked Sendable {}
extension Api_SubscriptionResponse: @unchecked Sendable {}
extension Api_PodcastPair: @unchecked Sendable {}
extension Api_SubscriptionsStatusResponse: @unchecked Sendable {}
extension Api_CancelUserSubscriptionRequest: @unchecked Sendable {}
extension Api_LegacyRequest: @unchecked Sendable {}
extension Api_LegacyResponse: @unchecked Sendable {}
extension Api_SyncUpdateRequest: @unchecked Sendable {}
extension Api_SyncUpdateResponse: @unchecked Sendable {}
extension Api_Record: @unchecked Sendable {}
extension Api_Record.OneOf_Record: @unchecked Sendable {}
extension Api_SyncUserPodcast: @unchecked Sendable {}
extension Api_SyncUserEpisode: @unchecked Sendable {}
extension Api_SyncUserDevice: @unchecked Sendable {}
extension Api_SyncUserPlaylist: @unchecked Sendable {}
extension Api_SyncUserFolder: @unchecked Sendable {}
extension Api_LegacySyncData: @unchecked Sendable {}
extension Api_LegacySyncRecord: @unchecked Sendable {}
extension Api_LegacyRecord: @unchecked Sendable {}
extension Api_LegacySyncResponse: @unchecked Sendable {}
extension Api_LegacySyncResponseRecord: @unchecked Sendable {}
extension Api_LegacyResponseRecord: @unchecked Sendable {}
extension Api_LegacyStatsResponse: @unchecked Sendable {}
extension Api_PromotionCode: @unchecked Sendable {}
extension Api_Promotion: @unchecked Sendable {}
extension Api_PodcastSubscriptionCheckRequest: @unchecked Sendable {}
extension Api_BundleUserRequest: @unchecked Sendable {}
extension Api_BundleUserResponse: @unchecked Sendable {}
extension Api_PodcastSubscriptionCheckResponse: @unchecked Sendable {}
extension Api_PodcastFolderRequest: @unchecked Sendable {}
extension Api_PodcastFolder: @unchecked Sendable {}
extension Api_PodcastFolderSortRequest: @unchecked Sendable {}
extension Api_PodcastFolderSorting: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api"

extension Api_UserChangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserChangeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._success {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserChangeResponse, rhs: Api_UserChangeResponse) -> Bool {
    if lhs._success != rhs._success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserResetPasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserResetPasswordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reset_password_token"),
    2: .same(proto: "password"),
    3: .same(proto: "scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resetPasswordToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resetPasswordToken.isEmpty {
      try visitor.visitSingularStringField(value: self.resetPasswordToken, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserResetPasswordRequest, rhs: Api_UserResetPasswordRequest) -> Bool {
    if lhs.resetPasswordToken != rhs.resetPasswordToken {return false}
    if lhs.password != rhs.password {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EmailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmailRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_EmailRequest, rhs: Api_EmailRequest) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserChangeEmailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserChangeEmailRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
    3: .same(proto: "scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserChangeEmailRequest, rhs: Api_UserChangeEmailRequest) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.password != rhs.password {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserChangePasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserChangePasswordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "old_password"),
    2: .standard(proto: "new_password"),
    4: .same(proto: "scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oldPassword) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newPassword) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oldPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.oldPassword, fieldNumber: 1)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.newPassword, fieldNumber: 2)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserChangePasswordRequest, rhs: Api_UserChangePasswordRequest) -> Bool {
    if lhs.oldPassword != rhs.oldPassword {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EmptyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmptyRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_EmptyRequest, rhs: Api_EmptyRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EmptyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmptyResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_EmptyResponse, rhs: Api_EmptyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SupportFeedbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupportFeedbackRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "email"),
    3: .same(proto: "subject"),
    4: .same(proto: "debug"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.debug) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 3)
    }
    if !self.debug.isEmpty {
      try visitor.visitSingularStringField(value: self.debug, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SupportFeedbackRequest, rhs: Api_SupportFeedbackRequest) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.email != rhs.email {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.debug != rhs.debug {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CreateBetaUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateBetaUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_CreateBetaUserRequest, rhs: Api_CreateBetaUserRequest) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLoginRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
    3: .same(proto: "scope"),
    4: .same(proto: "dt"),
    5: .same(proto: "device"),
    6: .same(proto: "v"),
    7: .same(proto: "m"),
    8: .same(proto: "av"),
    9: .same(proto: "f"),
    10: .same(proto: "l"),
    11: .same(proto: "c"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.device) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.m) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.av) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.f) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.l) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.c) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 3)
    }
    if !self.dt.isEmpty {
      try visitor.visitSingularStringField(value: self.dt, fieldNumber: 4)
    }
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 5)
    }
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 6)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 7)
    }
    if !self.av.isEmpty {
      try visitor.visitSingularStringField(value: self.av, fieldNumber: 8)
    }
    if !self.f.isEmpty {
      try visitor.visitSingularStringField(value: self.f, fieldNumber: 9)
    }
    if !self.l.isEmpty {
      try visitor.visitSingularStringField(value: self.l, fieldNumber: 10)
    }
    if !self.c.isEmpty {
      try visitor.visitSingularStringField(value: self.c, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserLoginRequest, rhs: Api_UserLoginRequest) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.password != rhs.password {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.dt != rhs.dt {return false}
    if lhs.device != rhs.device {return false}
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.av != rhs.av {return false}
    if lhs.f != rhs.f {return false}
    if lhs.l != rhs.l {return false}
    if lhs.c != rhs.c {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLoginResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserLoginResponse, rhs: Api_UserLoginResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_BasicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BasicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v"),
    2: .same(proto: "m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.m) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 1)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_BasicRequest, rhs: Api_BasicRequest) -> Bool {
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserIdResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserIdResponse, rhs: Api_UserIdResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserPlaylistEpisodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPlaylistEpisodesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v"),
    2: .same(proto: "m"),
    3: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.m) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 1)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 2)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserPlaylistEpisodesRequest, rhs: Api_UserPlaylistEpisodesRequest) -> Bool {
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserPlaylistListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPlaylistListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v"),
    2: .same(proto: "m"),
    3: .standard(proto: "exclude_deleted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.m) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.excludeDeleted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 1)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 2)
    }
    if self.excludeDeleted != false {
      try visitor.visitSingularBoolField(value: self.excludeDeleted, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserPlaylistListRequest, rhs: Api_UserPlaylistListRequest) -> Bool {
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.excludeDeleted != rhs.excludeDeleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserPodcastListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPodcastListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v"),
    2: .same(proto: "m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.m) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 1)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserPodcastListRequest, rhs: Api_UserPodcastListRequest) -> Bool {
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NamedSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamedSettingsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v"),
    2: .same(proto: "m"),
    3: .same(proto: "settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.m) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 1)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 2)
    }
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_NamedSettingsRequest, rhs: Api_NamedSettingsRequest) -> Bool {
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NamedSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamedSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "grid_layout"),
    2: .standard(proto: "grid_order"),
    3: .standard(proto: "show_played"),
    4: .same(proto: "theme"),
    5: .standard(proto: "skip_forward"),
    6: .standard(proto: "skip_back"),
    7: .standard(proto: "web_version"),
    8: .same(proto: "language"),
    9: .standard(proto: "recommendations_on"),
    10: .standard(proto: "stream_by_default"),
    11: .standard(proto: "use_embedded_artwork"),
    12: .standard(proto: "playback_speed"),
    13: .standard(proto: "silence_removal"),
    14: .standard(proto: "volume_boost"),
    15: .same(proto: "badges"),
    16: .standard(proto: "free_gift_acknowledgement"),
    17: .standard(proto: "marketing_opt_in"),
    18: .standard(proto: "auto_archive_played_episodes"),
    19: .standard(proto: "auto_archive_includes_starred"),
    20: .same(proto: "region"),
  ]

  fileprivate class _StorageClass {
    var _gridLayout: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _gridOrder: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _showPlayed: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _theme: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _skipForward: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _skipBack: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _webVersion: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _language: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _recommendationsOn: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _streamByDefault: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _useEmbeddedArtwork: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _playbackSpeed: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _silenceRemoval: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _volumeBoost: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _badges: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _freeGiftAcknowledgement: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _marketingOptIn: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _autoArchivePlayedEpisodes: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _autoArchiveIncludesStarred: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _region: SwiftProtobuf.Google_Protobuf_StringValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gridLayout = source._gridLayout
      _gridOrder = source._gridOrder
      _showPlayed = source._showPlayed
      _theme = source._theme
      _skipForward = source._skipForward
      _skipBack = source._skipBack
      _webVersion = source._webVersion
      _language = source._language
      _recommendationsOn = source._recommendationsOn
      _streamByDefault = source._streamByDefault
      _useEmbeddedArtwork = source._useEmbeddedArtwork
      _playbackSpeed = source._playbackSpeed
      _silenceRemoval = source._silenceRemoval
      _volumeBoost = source._volumeBoost
      _badges = source._badges
      _freeGiftAcknowledgement = source._freeGiftAcknowledgement
      _marketingOptIn = source._marketingOptIn
      _autoArchivePlayedEpisodes = source._autoArchivePlayedEpisodes
      _autoArchiveIncludesStarred = source._autoArchiveIncludesStarred
      _region = source._region
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._gridLayout) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._gridOrder) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._showPlayed) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._skipForward) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._skipBack) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._webVersion) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._language) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._recommendationsOn) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._streamByDefault) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._useEmbeddedArtwork) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._playbackSpeed) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._silenceRemoval) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._volumeBoost) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._badges) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._freeGiftAcknowledgement) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._marketingOptIn) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._autoArchivePlayedEpisodes) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._autoArchiveIncludesStarred) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._region) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._gridLayout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._gridOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._showPlayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._skipForward {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._skipBack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._webVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._language {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._recommendationsOn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._streamByDefault {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._useEmbeddedArtwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._playbackSpeed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._silenceRemoval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._volumeBoost {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._badges {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._freeGiftAcknowledgement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._marketingOptIn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._autoArchivePlayedEpisodes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._autoArchiveIncludesStarred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._region {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_NamedSettings, rhs: Api_NamedSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gridLayout != rhs_storage._gridLayout {return false}
        if _storage._gridOrder != rhs_storage._gridOrder {return false}
        if _storage._showPlayed != rhs_storage._showPlayed {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._skipForward != rhs_storage._skipForward {return false}
        if _storage._skipBack != rhs_storage._skipBack {return false}
        if _storage._webVersion != rhs_storage._webVersion {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._recommendationsOn != rhs_storage._recommendationsOn {return false}
        if _storage._streamByDefault != rhs_storage._streamByDefault {return false}
        if _storage._useEmbeddedArtwork != rhs_storage._useEmbeddedArtwork {return false}
        if _storage._playbackSpeed != rhs_storage._playbackSpeed {return false}
        if _storage._silenceRemoval != rhs_storage._silenceRemoval {return false}
        if _storage._volumeBoost != rhs_storage._volumeBoost {return false}
        if _storage._badges != rhs_storage._badges {return false}
        if _storage._freeGiftAcknowledgement != rhs_storage._freeGiftAcknowledgement {return false}
        if _storage._marketingOptIn != rhs_storage._marketingOptIn {return false}
        if _storage._autoArchivePlayedEpisodes != rhs_storage._autoArchivePlayedEpisodes {return false}
        if _storage._autoArchiveIncludesStarred != rhs_storage._autoArchiveIncludesStarred {return false}
        if _storage._region != rhs_storage._region {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NamedSettingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamedSettingsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "grid_layout"),
    2: .standard(proto: "grid_order"),
    3: .standard(proto: "show_played"),
    4: .same(proto: "theme"),
    5: .standard(proto: "skip_forward"),
    6: .standard(proto: "skip_back"),
    7: .standard(proto: "web_version"),
    8: .same(proto: "language"),
    9: .standard(proto: "recommendations_on"),
    10: .standard(proto: "stream_by_default"),
    11: .standard(proto: "use_embedded_artwork"),
    12: .standard(proto: "playback_speed"),
    13: .standard(proto: "silence_removal"),
    14: .standard(proto: "volume_boost"),
    15: .same(proto: "badges"),
    16: .standard(proto: "free_gift_acknowledgement"),
    17: .standard(proto: "marketing_opt_in"),
    18: .standard(proto: "auto_archive_played_episodes"),
    19: .standard(proto: "auto_archive_includes_starred"),
    20: .same(proto: "region"),
  ]

  fileprivate class _StorageClass {
    var _gridLayout: Api_Int32Setting? = nil
    var _gridOrder: Api_Int32Setting? = nil
    var _showPlayed: Api_Int32Setting? = nil
    var _theme: Api_Int32Setting? = nil
    var _skipForward: Api_Int32Setting? = nil
    var _skipBack: Api_Int32Setting? = nil
    var _webVersion: Api_Int32Setting? = nil
    var _language: Api_StringSetting? = nil
    var _recommendationsOn: Api_BoolSetting? = nil
    var _streamByDefault: Api_BoolSetting? = nil
    var _useEmbeddedArtwork: Api_BoolSetting? = nil
    var _playbackSpeed: Api_DoubleSetting? = nil
    var _silenceRemoval: Api_BoolSetting? = nil
    var _volumeBoost: Api_BoolSetting? = nil
    var _badges: Api_Int32Setting? = nil
    var _freeGiftAcknowledgement: Api_BoolSetting? = nil
    var _marketingOptIn: Api_BoolSetting? = nil
    var _autoArchivePlayedEpisodes: Api_BoolSetting? = nil
    var _autoArchiveIncludesStarred: Api_BoolSetting? = nil
    var _region: Api_StringSetting? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gridLayout = source._gridLayout
      _gridOrder = source._gridOrder
      _showPlayed = source._showPlayed
      _theme = source._theme
      _skipForward = source._skipForward
      _skipBack = source._skipBack
      _webVersion = source._webVersion
      _language = source._language
      _recommendationsOn = source._recommendationsOn
      _streamByDefault = source._streamByDefault
      _useEmbeddedArtwork = source._useEmbeddedArtwork
      _playbackSpeed = source._playbackSpeed
      _silenceRemoval = source._silenceRemoval
      _volumeBoost = source._volumeBoost
      _badges = source._badges
      _freeGiftAcknowledgement = source._freeGiftAcknowledgement
      _marketingOptIn = source._marketingOptIn
      _autoArchivePlayedEpisodes = source._autoArchivePlayedEpisodes
      _autoArchiveIncludesStarred = source._autoArchiveIncludesStarred
      _region = source._region
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._gridLayout) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._gridOrder) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._showPlayed) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._skipForward) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._skipBack) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._webVersion) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._language) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._recommendationsOn) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._streamByDefault) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._useEmbeddedArtwork) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._playbackSpeed) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._silenceRemoval) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._volumeBoost) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._badges) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._freeGiftAcknowledgement) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._marketingOptIn) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._autoArchivePlayedEpisodes) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._autoArchiveIncludesStarred) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._region) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._gridLayout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._gridOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._showPlayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._skipForward {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._skipBack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._webVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._language {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._recommendationsOn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._streamByDefault {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._useEmbeddedArtwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._playbackSpeed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._silenceRemoval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._volumeBoost {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._badges {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._freeGiftAcknowledgement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._marketingOptIn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._autoArchivePlayedEpisodes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._autoArchiveIncludesStarred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._region {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_NamedSettingsResponse, rhs: Api_NamedSettingsResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gridLayout != rhs_storage._gridLayout {return false}
        if _storage._gridOrder != rhs_storage._gridOrder {return false}
        if _storage._showPlayed != rhs_storage._showPlayed {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._skipForward != rhs_storage._skipForward {return false}
        if _storage._skipBack != rhs_storage._skipBack {return false}
        if _storage._webVersion != rhs_storage._webVersion {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._recommendationsOn != rhs_storage._recommendationsOn {return false}
        if _storage._streamByDefault != rhs_storage._streamByDefault {return false}
        if _storage._useEmbeddedArtwork != rhs_storage._useEmbeddedArtwork {return false}
        if _storage._playbackSpeed != rhs_storage._playbackSpeed {return false}
        if _storage._silenceRemoval != rhs_storage._silenceRemoval {return false}
        if _storage._volumeBoost != rhs_storage._volumeBoost {return false}
        if _storage._badges != rhs_storage._badges {return false}
        if _storage._freeGiftAcknowledgement != rhs_storage._freeGiftAcknowledgement {return false}
        if _storage._marketingOptIn != rhs_storage._marketingOptIn {return false}
        if _storage._autoArchivePlayedEpisodes != rhs_storage._autoArchivePlayedEpisodes {return false}
        if _storage._autoArchiveIncludesStarred != rhs_storage._autoArchiveIncludesStarred {return false}
        if _storage._region != rhs_storage._region {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Int32Setting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Int32Setting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "changed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._changed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._changed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_Int32Setting, rhs: Api_Int32Setting) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._changed != rhs._changed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_BoolSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoolSetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "changed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._changed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._changed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_BoolSetting, rhs: Api_BoolSetting) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._changed != rhs._changed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_StringSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringSetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "changed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._changed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._changed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_StringSetting, rhs: Api_StringSetting) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._changed != rhs._changed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_DoubleSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoubleSetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "changed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._changed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._changed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_DoubleSetting, rhs: Api_DoubleSetting) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._changed != rhs._changed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_ApiPodcastResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApiPodcastResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "title"),
    3: .same(proto: "author"),
    4: .same(proto: "description"),
    5: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.author) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.author.isEmpty {
      try visitor.visitSingularStringField(value: self.author, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_ApiPodcastResponse, rhs: Api_ApiPodcastResponse) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.title != rhs.title {return false}
    if lhs.author != rhs.author {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_ApiPodcastListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApiPodcastListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podcasts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.podcasts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcasts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.podcasts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_ApiPodcastListResponse, rhs: Api_ApiPodcastListResponse) -> Bool {
    if lhs.podcasts != rhs.podcasts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserPodcastResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPodcastResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "episodes_sort_order"),
    3: .standard(proto: "auto_start_from"),
    4: .same(proto: "title"),
    5: .same(proto: "author"),
    6: .same(proto: "description"),
    7: .same(proto: "url"),
    8: .standard(proto: "last_episode_published"),
    9: .same(proto: "unplayed"),
    10: .standard(proto: "last_episode_uuid"),
    11: .standard(proto: "last_episode_playing_status"),
    12: .standard(proto: "last_episode_archived"),
    13: .standard(proto: "auto_skip_last"),
    14: .standard(proto: "folder_uuid"),
    15: .standard(proto: "sort_position"),
    16: .standard(proto: "date_added"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _episodesSortOrder: Int32 = 0
    var _autoStartFrom: Int32 = 0
    var _title: String = String()
    var _author: String = String()
    var _description_p: String = String()
    var _url: String = String()
    var _lastEpisodePublished: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _unplayed: Bool = false
    var _lastEpisodeUuid: String = String()
    var _lastEpisodePlayingStatus: Int32 = 0
    var _lastEpisodeArchived: Bool = false
    var _autoSkipLast: Int32 = 0
    var _folderUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _episodesSortOrder = source._episodesSortOrder
      _autoStartFrom = source._autoStartFrom
      _title = source._title
      _author = source._author
      _description_p = source._description_p
      _url = source._url
      _lastEpisodePublished = source._lastEpisodePublished
      _unplayed = source._unplayed
      _lastEpisodeUuid = source._lastEpisodeUuid
      _lastEpisodePlayingStatus = source._lastEpisodePlayingStatus
      _lastEpisodeArchived = source._lastEpisodeArchived
      _autoSkipLast = source._autoSkipLast
      _folderUuid = source._folderUuid
      _sortPosition = source._sortPosition
      _dateAdded = source._dateAdded
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._episodesSortOrder) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._autoStartFrom) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._author) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastEpisodePublished) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._unplayed) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._lastEpisodeUuid) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._lastEpisodePlayingStatus) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._lastEpisodeArchived) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._autoSkipLast) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._folderUuid) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._sortPosition) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._dateAdded) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      if _storage._episodesSortOrder != 0 {
        try visitor.visitSingularInt32Field(value: _storage._episodesSortOrder, fieldNumber: 2)
      }
      if _storage._autoStartFrom != 0 {
        try visitor.visitSingularInt32Field(value: _storage._autoStartFrom, fieldNumber: 3)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 4)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularStringField(value: _storage._author, fieldNumber: 5)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 6)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 7)
      }
      try { if let v = _storage._lastEpisodePublished {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._unplayed != false {
        try visitor.visitSingularBoolField(value: _storage._unplayed, fieldNumber: 9)
      }
      if !_storage._lastEpisodeUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastEpisodeUuid, fieldNumber: 10)
      }
      if _storage._lastEpisodePlayingStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lastEpisodePlayingStatus, fieldNumber: 11)
      }
      if _storage._lastEpisodeArchived != false {
        try visitor.visitSingularBoolField(value: _storage._lastEpisodeArchived, fieldNumber: 12)
      }
      if _storage._autoSkipLast != 0 {
        try visitor.visitSingularInt32Field(value: _storage._autoSkipLast, fieldNumber: 13)
      }
      try { if let v = _storage._folderUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._sortPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._dateAdded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserPodcastResponse, rhs: Api_UserPodcastResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._episodesSortOrder != rhs_storage._episodesSortOrder {return false}
        if _storage._autoStartFrom != rhs_storage._autoStartFrom {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._lastEpisodePublished != rhs_storage._lastEpisodePublished {return false}
        if _storage._unplayed != rhs_storage._unplayed {return false}
        if _storage._lastEpisodeUuid != rhs_storage._lastEpisodeUuid {return false}
        if _storage._lastEpisodePlayingStatus != rhs_storage._lastEpisodePlayingStatus {return false}
        if _storage._lastEpisodeArchived != rhs_storage._lastEpisodeArchived {return false}
        if _storage._autoSkipLast != rhs_storage._autoSkipLast {return false}
        if _storage._folderUuid != rhs_storage._folderUuid {return false}
        if _storage._sortPosition != rhs_storage._sortPosition {return false}
        if _storage._dateAdded != rhs_storage._dateAdded {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserPlaylistListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPlaylistListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.playlists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.playlists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.playlists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserPlaylistListResponse, rhs: Api_UserPlaylistListResponse) -> Bool {
    if lhs.playlists != rhs.playlists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserPodcastListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPodcastListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podcasts"),
    2: .same(proto: "folders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.podcasts) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.folders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcasts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.podcasts, fieldNumber: 1)
    }
    if !self.folders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.folders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserPodcastListResponse, rhs: Api_UserPodcastListResponse) -> Bool {
    if lhs.podcasts != rhs.podcasts {return false}
    if lhs.folders != rhs.folders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserLastSyncAtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLastSyncAtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_sync_at"),
    2: .standard(proto: "last_sync_at_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lastSyncAt) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastSyncAtMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastSyncAt.isEmpty {
      try visitor.visitSingularStringField(value: self.lastSyncAt, fieldNumber: 1)
    }
    if self.lastSyncAtMs != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSyncAtMs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserLastSyncAtResponse, rhs: Api_UserLastSyncAtResponse) -> Bool {
    if lhs.lastSyncAt != rhs.lastSyncAt {return false}
    if lhs.lastSyncAtMs != rhs.lastSyncAtMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UuidRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UuidRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v"),
    2: .same(proto: "m"),
    3: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.m) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 1)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 2)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UuidRequest, rhs: Api_UuidRequest) -> Bool {
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_KeywordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeywordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v"),
    2: .same(proto: "m"),
    3: .same(proto: "keyword"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.m) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 1)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 2)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_KeywordRequest, rhs: Api_KeywordRequest) -> Bool {
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncEpisodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncEpisodesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "episodes"),
    2: .standard(proto: "auto_start_from"),
    3: .standard(proto: "episodes_sort_order"),
    4: .standard(proto: "auto_skip_last"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.episodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._autoStartFrom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._episodesSortOrder) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._autoSkipLast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.episodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.episodes, fieldNumber: 1)
    }
    try { if let v = self._autoStartFrom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._episodesSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._autoSkipLast {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncEpisodesResponse, rhs: Api_SyncEpisodesResponse) -> Bool {
    if lhs.episodes != rhs.episodes {return false}
    if lhs._autoStartFrom != rhs._autoStartFrom {return false}
    if lhs._episodesSortOrder != rhs._episodesSortOrder {return false}
    if lhs._autoSkipLast != rhs._autoSkipLast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_FindUserEpisodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FindUserEpisodesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_uuid"),
    2: .same(proto: "page"),
    3: .same(proto: "sort"),
    4: .same(proto: "v"),
    5: .same(proto: "m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastUuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sort) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.m) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcastUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastUuid, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.sort != 0 {
      try visitor.visitSingularInt32Field(value: self.sort, fieldNumber: 3)
    }
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 4)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_FindUserEpisodesRequest, rhs: Api_FindUserEpisodesRequest) -> Bool {
    if lhs.podcastUuid != rhs.podcastUuid {return false}
    if lhs.page != rhs.page {return false}
    if lhs.sort != rhs.sort {return false}
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EpisodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpisodesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "episodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.episodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if !self.episodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.episodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_EpisodesResponse, rhs: Api_EpisodesResponse) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.episodes != rhs.episodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_FindUserEpisodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FindUserEpisodeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "v"),
    3: .same(proto: "m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.v) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.m) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.v.isEmpty {
      try visitor.visitSingularStringField(value: self.v, fieldNumber: 2)
    }
    if !self.m.isEmpty {
      try visitor.visitSingularStringField(value: self.m, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_FindUserEpisodeRequest, rhs: Api_FindUserEpisodeRequest) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.v != rhs.v {return false}
    if lhs.m != rhs.m {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EpisodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpisodeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "url"),
    3: .same(proto: "published"),
    4: .same(proto: "duration"),
    5: .standard(proto: "file_type"),
    6: .same(proto: "title"),
    7: .same(proto: "size"),
    8: .standard(proto: "playing_status"),
    9: .standard(proto: "played_up_to"),
    10: .same(proto: "starred"),
    11: .standard(proto: "podcast_uuid"),
    12: .standard(proto: "podcast_title"),
    13: .standard(proto: "episode_type"),
    14: .standard(proto: "episode_season"),
    15: .standard(proto: "episode_number"),
    16: .standard(proto: "is_deleted"),
    17: .same(proto: "author"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _url: String = String()
    var _published: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _duration: Int32 = 0
    var _fileType: String = String()
    var _title: String = String()
    var _size: Int64 = 0
    var _playingStatus: Int32 = 0
    var _playedUpTo: Int32 = 0
    var _starred: Bool = false
    var _podcastUuid: String = String()
    var _podcastTitle: String = String()
    var _episodeType: String = String()
    var _episodeSeason: Int32 = 0
    var _episodeNumber: Int32 = 0
    var _isDeleted: Bool = false
    var _author: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _url = source._url
      _published = source._published
      _duration = source._duration
      _fileType = source._fileType
      _title = source._title
      _size = source._size
      _playingStatus = source._playingStatus
      _playedUpTo = source._playedUpTo
      _starred = source._starred
      _podcastUuid = source._podcastUuid
      _podcastTitle = source._podcastTitle
      _episodeType = source._episodeType
      _episodeSeason = source._episodeSeason
      _episodeNumber = source._episodeNumber
      _isDeleted = source._isDeleted
      _author = source._author
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._published) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._fileType) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._size) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._playingStatus) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._playedUpTo) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._starred) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._podcastUuid) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._podcastTitle) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._episodeType) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._episodeSeason) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._episodeNumber) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isDeleted) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._author) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 2)
      }
      try { if let v = _storage._published {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 4)
      }
      if !_storage._fileType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fileType, fieldNumber: 5)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 6)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt64Field(value: _storage._size, fieldNumber: 7)
      }
      if _storage._playingStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._playingStatus, fieldNumber: 8)
      }
      if _storage._playedUpTo != 0 {
        try visitor.visitSingularInt32Field(value: _storage._playedUpTo, fieldNumber: 9)
      }
      if _storage._starred != false {
        try visitor.visitSingularBoolField(value: _storage._starred, fieldNumber: 10)
      }
      if !_storage._podcastUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._podcastUuid, fieldNumber: 11)
      }
      if !_storage._podcastTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._podcastTitle, fieldNumber: 12)
      }
      if !_storage._episodeType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._episodeType, fieldNumber: 13)
      }
      if _storage._episodeSeason != 0 {
        try visitor.visitSingularInt32Field(value: _storage._episodeSeason, fieldNumber: 14)
      }
      if _storage._episodeNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._episodeNumber, fieldNumber: 15)
      }
      if _storage._isDeleted != false {
        try visitor.visitSingularBoolField(value: _storage._isDeleted, fieldNumber: 16)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularStringField(value: _storage._author, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_EpisodeResponse, rhs: Api_EpisodeResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._published != rhs_storage._published {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._fileType != rhs_storage._fileType {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._playingStatus != rhs_storage._playingStatus {return false}
        if _storage._playedUpTo != rhs_storage._playedUpTo {return false}
        if _storage._starred != rhs_storage._starred {return false}
        if _storage._podcastUuid != rhs_storage._podcastUuid {return false}
        if _storage._podcastTitle != rhs_storage._podcastTitle {return false}
        if _storage._episodeType != rhs_storage._episodeType {return false}
        if _storage._episodeSeason != rhs_storage._episodeSeason {return false}
        if _storage._episodeNumber != rhs_storage._episodeNumber {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        if _storage._author != rhs_storage._author {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncUpdateEpisodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncUpdateEpisodeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncUpdateEpisodeResponse, rhs: Api_SyncUpdateEpisodeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpdateEpisodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateEpisodeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "podcast"),
    3: .same(proto: "position"),
    4: .same(proto: "status"),
    5: .same(proto: "duration"),
    6: .same(proto: "stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podcast) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.podcast.isEmpty {
      try visitor.visitSingularStringField(value: self.podcast, fieldNumber: 2)
    }
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 5)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpdateEpisodeRequest, rhs: Api_UpdateEpisodeRequest) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.podcast != rhs.podcast {return false}
    if lhs._position != rhs._position {return false}
    if lhs.status != rhs.status {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpdateEpisodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateEpisodeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpdateEpisodeResponse, rhs: Api_UpdateEpisodeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_StatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "time_silence_removal"),
    3: .standard(proto: "time_skipping"),
    4: .standard(proto: "time_intro_skipping"),
    5: .standard(proto: "time_variable_speed"),
    6: .standard(proto: "time_listened"),
    7: .standard(proto: "device_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.timeSilenceRemoval) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timeSkipping) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.timeIntroSkipping) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.timeVariableSpeed) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.timeListened) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.deviceType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.timeSilenceRemoval != 0 {
      try visitor.visitSingularInt32Field(value: self.timeSilenceRemoval, fieldNumber: 2)
    }
    if self.timeSkipping != 0 {
      try visitor.visitSingularInt32Field(value: self.timeSkipping, fieldNumber: 3)
    }
    if self.timeIntroSkipping != 0 {
      try visitor.visitSingularInt32Field(value: self.timeIntroSkipping, fieldNumber: 4)
    }
    if self.timeVariableSpeed != 0 {
      try visitor.visitSingularInt32Field(value: self.timeVariableSpeed, fieldNumber: 5)
    }
    if self.timeListened != 0 {
      try visitor.visitSingularInt32Field(value: self.timeListened, fieldNumber: 6)
    }
    if self.deviceType != 0 {
      try visitor.visitSingularInt32Field(value: self.deviceType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_StatsRequest, rhs: Api_StatsRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.timeSilenceRemoval != rhs.timeSilenceRemoval {return false}
    if lhs.timeSkipping != rhs.timeSkipping {return false}
    if lhs.timeIntroSkipping != rhs.timeIntroSkipping {return false}
    if lhs.timeVariableSpeed != rhs.timeVariableSpeed {return false}
    if lhs.timeListened != rhs.timeListened {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpdateEpisodeStarRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateEpisodeStarRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "podcast"),
    3: .same(proto: "star"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podcast) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.star) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.podcast.isEmpty {
      try visitor.visitSingularStringField(value: self.podcast, fieldNumber: 2)
    }
    if self.star != false {
      try visitor.visitSingularBoolField(value: self.star, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpdateEpisodeStarRequest, rhs: Api_UpdateEpisodeStarRequest) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.podcast != rhs.podcast {return false}
    if lhs.star != rhs.star {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpdateEpisodeStarResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateEpisodeStarResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpdateEpisodeStarResponse, rhs: Api_UpdateEpisodeStarResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EpisodeWithPodcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpisodeWithPodcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "podcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.podcast.isEmpty {
      try visitor.visitSingularStringField(value: self.podcast, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_EpisodeWithPodcast, rhs: Api_EpisodeWithPodcast) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.podcast != rhs.podcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpdateEpisodesArchiveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateEpisodesArchiveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "archive"),
    2: .same(proto: "episodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.archive) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.episodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.archive != false {
      try visitor.visitSingularBoolField(value: self.archive, fieldNumber: 1)
    }
    if !self.episodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.episodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpdateEpisodesArchiveRequest, rhs: Api_UpdateEpisodesArchiveRequest) -> Bool {
    if lhs.archive != rhs.archive {return false}
    if lhs.episodes != rhs.episodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextSyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpNextSyncRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_time"),
    2: .same(proto: "version"),
    3: .same(proto: "model"),
    4: .standard(proto: "up_next"),
    5: .standard(proto: "show_play_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.deviceTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._upNext) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.showPlayStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.deviceTime != 0 {
      try visitor.visitSingularInt64Field(value: self.deviceTime, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 3)
    }
    try { if let v = self._upNext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.showPlayStatus != false {
      try visitor.visitSingularBoolField(value: self.showPlayStatus, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextSyncRequest, rhs: Api_UpNextSyncRequest) -> Bool {
    if lhs.deviceTime != rhs.deviceTime {return false}
    if lhs.version != rhs.version {return false}
    if lhs.model != rhs.model {return false}
    if lhs._upNext != rhs._upNext {return false}
    if lhs.showPlayStatus != rhs.showPlayStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextPlayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpNextPlayRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "model"),
    3: .same(proto: "episode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._episode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    try { if let v = self._episode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextPlayRequest, rhs: Api_UpNextPlayRequest) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.model != rhs.model {return false}
    if lhs._episode != rhs._episode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpNextListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .same(proto: "version"),
    3: .same(proto: "model"),
    4: .standard(proto: "server_modified"),
    5: .standard(proto: "show_play_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.serverModified) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.showPlayStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 3)
    }
    if self.serverModified != 0 {
      try visitor.visitSingularInt64Field(value: self.serverModified, fieldNumber: 4)
    }
    if self.showPlayStatus != false {
      try visitor.visitSingularBoolField(value: self.showPlayStatus, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextListRequest, rhs: Api_UpNextListRequest) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.version != rhs.version {return false}
    if lhs.model != rhs.model {return false}
    if lhs.serverModified != rhs.serverModified {return false}
    if lhs.showPlayStatus != rhs.showPlayStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextEpisodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpNextEpisodeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    4: .same(proto: "title"),
    5: .same(proto: "url"),
    6: .same(proto: "podcast"),
    7: .same(proto: "published"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.podcast) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._published) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    if !self.podcast.isEmpty {
      try visitor.visitSingularStringField(value: self.podcast, fieldNumber: 6)
    }
    try { if let v = self._published {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextEpisodeRequest, rhs: Api_UpNextEpisodeRequest) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.title != rhs.title {return false}
    if lhs.url != rhs.url {return false}
    if lhs.podcast != rhs.podcast {return false}
    if lhs._published != rhs._published {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextChanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpNextChanges"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_modified"),
    2: .same(proto: "changes"),
    3: .same(proto: "order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.serverModified) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.changes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverModified != 0 {
      try visitor.visitSingularInt64Field(value: self.serverModified, fieldNumber: 1)
    }
    if !self.changes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changes, fieldNumber: 2)
    }
    if !self.order.isEmpty {
      try visitor.visitRepeatedStringField(value: self.order, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextChanges, rhs: Api_UpNextChanges) -> Bool {
    if lhs.serverModified != rhs.serverModified {return false}
    if lhs.changes != rhs.changes {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextChanges.Change: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Api_UpNextChanges.protoMessageName + ".Change"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "action"),
    3: .same(proto: "modified"),
    4: .same(proto: "title"),
    5: .same(proto: "url"),
    6: .same(proto: "podcast"),
    7: .same(proto: "episodes"),
    8: .same(proto: "published"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.action) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.modified) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.podcast) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.episodes) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._published) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.action != 0 {
      try visitor.visitSingularInt32Field(value: self.action, fieldNumber: 2)
    }
    if self.modified != 0 {
      try visitor.visitSingularInt64Field(value: self.modified, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    if !self.podcast.isEmpty {
      try visitor.visitSingularStringField(value: self.podcast, fieldNumber: 6)
    }
    if !self.episodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.episodes, fieldNumber: 7)
    }
    try { if let v = self._published {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextChanges.Change, rhs: Api_UpNextChanges.Change) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.action != rhs.action {return false}
    if lhs.modified != rhs.modified {return false}
    if lhs.title != rhs.title {return false}
    if lhs.url != rhs.url {return false}
    if lhs.podcast != rhs.podcast {return false}
    if lhs.episodes != rhs.episodes {return false}
    if lhs._published != rhs._published {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpNextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_modified"),
    4: .same(proto: "episodes"),
    5: .same(proto: "episodeSync"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.serverModified) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.episodes) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.episodeSync) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverModified != 0 {
      try visitor.visitSingularInt64Field(value: self.serverModified, fieldNumber: 1)
    }
    if !self.episodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.episodes, fieldNumber: 4)
    }
    if !self.episodeSync.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.episodeSync, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextResponse, rhs: Api_UpNextResponse) -> Bool {
    if lhs.serverModified != rhs.serverModified {return false}
    if lhs.episodes != rhs.episodes {return false}
    if lhs.episodeSync != rhs.episodeSync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextResponse.EpisodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Api_UpNextResponse.protoMessageName + ".EpisodeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "url"),
    3: .same(proto: "podcast"),
    4: .same(proto: "uuid"),
    5: .same(proto: "published"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.podcast) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._published) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.podcast.isEmpty {
      try visitor.visitSingularStringField(value: self.podcast, fieldNumber: 3)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 4)
    }
    try { if let v = self._published {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextResponse.EpisodeResponse, rhs: Api_UpNextResponse.EpisodeResponse) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.url != rhs.url {return false}
    if lhs.podcast != rhs.podcast {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs._published != rhs._published {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextResponse.EpisodeSyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Api_UpNextResponse.protoMessageName + ".EpisodeSyncResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    6: .standard(proto: "played_up_to"),
    7: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._playedUpTo) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    try { if let v = self._playedUpTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextResponse.EpisodeSyncResponse, rhs: Api_UpNextResponse.EpisodeSyncResponse) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs._playedUpTo != rhs._playedUpTo {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_HistoryChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "podcast"),
    3: .same(proto: "episode"),
    4: .standard(proto: "modified_at"),
    5: .same(proto: "title"),
    6: .same(proto: "url"),
    7: .same(proto: "published"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podcast) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.episode) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.modifiedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._published) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != 0 {
      try visitor.visitSingularInt32Field(value: self.action, fieldNumber: 1)
    }
    if !self.podcast.isEmpty {
      try visitor.visitSingularStringField(value: self.podcast, fieldNumber: 2)
    }
    if !self.episode.isEmpty {
      try visitor.visitSingularStringField(value: self.episode, fieldNumber: 3)
    }
    if self.modifiedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.modifiedAt, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    try { if let v = self._published {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_HistoryChange, rhs: Api_HistoryChange) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.podcast != rhs.podcast {return false}
    if lhs.episode != rhs.episode {return false}
    if lhs.modifiedAt != rhs.modifiedAt {return false}
    if lhs.title != rhs.title {return false}
    if lhs.url != rhs.url {return false}
    if lhs._published != rhs._published {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_HistorySyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistorySyncRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_time"),
    2: .standard(proto: "server_modified"),
    3: .same(proto: "changes"),
    4: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.deviceTime) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.serverModified) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.changes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceTime != 0 {
      try visitor.visitSingularInt64Field(value: self.deviceTime, fieldNumber: 1)
    }
    if self.serverModified != 0 {
      try visitor.visitSingularInt64Field(value: self.serverModified, fieldNumber: 2)
    }
    if !self.changes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changes, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_HistorySyncRequest, rhs: Api_HistorySyncRequest) -> Bool {
    if lhs.deviceTime != rhs.deviceTime {return false}
    if lhs.serverModified != rhs.serverModified {return false}
    if lhs.changes != rhs.changes {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_HistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_modified"),
    2: .standard(proto: "last_cleared"),
    3: .same(proto: "changes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.serverModified) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastCleared) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.changes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverModified != 0 {
      try visitor.visitSingularInt64Field(value: self.serverModified, fieldNumber: 1)
    }
    if self.lastCleared != 0 {
      try visitor.visitSingularInt64Field(value: self.lastCleared, fieldNumber: 2)
    }
    if !self.changes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_HistoryResponse, rhs: Api_HistoryResponse) -> Bool {
    if lhs.serverModified != rhs.serverModified {return false}
    if lhs.lastCleared != rhs.lastCleared {return false}
    if lhs.changes != rhs.changes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UpNextRemoveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpNextRemoveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuids"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.uuids) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uuids, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UpNextRemoveRequest, rhs: Api_UpNextRemoveRequest) -> Bool {
    if lhs.uuids != rhs.uuids {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EpisodeSyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpisodeSyncResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "playing_status"),
    3: .standard(proto: "played_up_to"),
    4: .standard(proto: "is_deleted"),
    5: .same(proto: "starred"),
    6: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.playingStatus) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.playedUpTo) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isDeleted) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.starred) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.playingStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.playingStatus, fieldNumber: 2)
    }
    if self.playedUpTo != 0 {
      try visitor.visitSingularInt32Field(value: self.playedUpTo, fieldNumber: 3)
    }
    if self.isDeleted != false {
      try visitor.visitSingularBoolField(value: self.isDeleted, fieldNumber: 4)
    }
    if self.starred != false {
      try visitor.visitSingularBoolField(value: self.starred, fieldNumber: 5)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_EpisodeSyncResponse, rhs: Api_EpisodeSyncResponse) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.playingStatus != rhs.playingStatus {return false}
    if lhs.playedUpTo != rhs.playedUpTo {return false}
    if lhs.isDeleted != rhs.isDeleted {return false}
    if lhs.starred != rhs.starred {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SearchPodcastsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchPodcastsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "term"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.term) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.term.isEmpty {
      try visitor.visitSingularStringField(value: self.term, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SearchPodcastsRequest, rhs: Api_SearchPodcastsRequest) -> Bool {
    if lhs.term != rhs.term {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_HealthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ok"),
    2: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_HealthResponse, rhs: Api_HealthResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_StatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_silence_removal"),
    2: .standard(proto: "time_skipping"),
    3: .standard(proto: "time_intro_skipping"),
    4: .standard(proto: "time_variable_speed"),
    5: .standard(proto: "time_listened"),
    6: .standard(proto: "times_started_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timeSilenceRemoval) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeSkipping) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timeIntroSkipping) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timeVariableSpeed) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.timeListened) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timesStartedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timeSilenceRemoval != 0 {
      try visitor.visitSingularInt64Field(value: self.timeSilenceRemoval, fieldNumber: 1)
    }
    if self.timeSkipping != 0 {
      try visitor.visitSingularInt64Field(value: self.timeSkipping, fieldNumber: 2)
    }
    if self.timeIntroSkipping != 0 {
      try visitor.visitSingularInt64Field(value: self.timeIntroSkipping, fieldNumber: 3)
    }
    if self.timeVariableSpeed != 0 {
      try visitor.visitSingularInt64Field(value: self.timeVariableSpeed, fieldNumber: 4)
    }
    if self.timeListened != 0 {
      try visitor.visitSingularInt64Field(value: self.timeListened, fieldNumber: 5)
    }
    try { if let v = self._timesStartedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_StatsResponse, rhs: Api_StatsResponse) -> Bool {
    if lhs.timeSilenceRemoval != rhs.timeSilenceRemoval {return false}
    if lhs.timeSkipping != rhs.timeSkipping {return false}
    if lhs.timeIntroSkipping != rhs.timeIntroSkipping {return false}
    if lhs.timeVariableSpeed != rhs.timeVariableSpeed {return false}
    if lhs.timeListened != rhs.timeListened {return false}
    if lhs._timesStartedAt != rhs._timesStartedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RegisterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
    3: .same(proto: "scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RegisterRequest, rhs: Api_RegisterRequest) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.password != rhs.password {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserAuthorizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserAuthorizeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
    3: .standard(proto: "response_type"),
    4: .standard(proto: "client_id"),
    5: .standard(proto: "redirect_uri"),
    6: .same(proto: "scope"),
    7: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.responseType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.redirectUri) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.responseType.isEmpty {
      try visitor.visitSingularStringField(value: self.responseType, fieldNumber: 3)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 4)
    }
    if !self.redirectUri.isEmpty {
      try visitor.visitSingularStringField(value: self.redirectUri, fieldNumber: 5)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 6)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserAuthorizeRequest, rhs: Api_UserAuthorizeRequest) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.password != rhs.password {return false}
    if lhs.responseType != rhs.responseType {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.redirectUri != rhs.redirectUri {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "grant_type"),
    3: .standard(proto: "refresh_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.grantType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.grantType.isEmpty {
      try visitor.visitSingularStringField(value: self.grantType, fieldNumber: 2)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserTokenRequest, rhs: Api_UserTokenRequest) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.grantType != rhs.grantType {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .standard(proto: "token_type"),
    3: .standard(proto: "expires_in"),
    4: .standard(proto: "refresh_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.expiresIn) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._refreshToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 1)
    }
    if !self.tokenType.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenType, fieldNumber: 2)
    }
    if self.expiresIn != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresIn, fieldNumber: 3)
    }
    try { if let v = self._refreshToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserTokenResponse, rhs: Api_UserTokenResponse) -> Bool {
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.expiresIn != rhs.expiresIn {return false}
    if lhs._refreshToken != rhs._refreshToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserRevokeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserRevokeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "refresh_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserRevokeRequest, rhs: Api_UserRevokeRequest) -> Bool {
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_UserAuthorizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserAuthorizeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "code"),
    3: .same(proto: "error"),
    4: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_UserAuthorizeResponse, rhs: Api_UserAuthorizeResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.code != rhs.code {return false}
    if lhs.error != rhs.error {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "message"),
    3: .same(proto: "token"),
    4: .same(proto: "uuid"),
    5: .same(proto: "errors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.errors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._success {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 4)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedStringField(value: self.errors, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RegisterResponse, rhs: Api_RegisterResponse) -> Bool {
    if lhs._success != rhs._success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.token != rhs.token {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_StarredEpisodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StarredEpisodesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "episodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.episodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.episodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.episodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_StarredEpisodesResponse, rhs: Api_StarredEpisodesResponse) -> Bool {
    if lhs.episodes != rhs.episodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_StarredEpisode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StarredEpisode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "podcast_uuid"),
    3: .same(proto: "duration"),
    4: .standard(proto: "playing_status"),
    5: .standard(proto: "played_up_to"),
    6: .standard(proto: "is_deleted"),
    7: .standard(proto: "starred_modified"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podcastUuid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.playingStatus) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.playedUpTo) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isDeleted) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.starredModified) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.podcastUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastUuid, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 3)
    }
    if self.playingStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.playingStatus, fieldNumber: 4)
    }
    if self.playedUpTo != 0 {
      try visitor.visitSingularInt32Field(value: self.playedUpTo, fieldNumber: 5)
    }
    if self.isDeleted != false {
      try visitor.visitSingularBoolField(value: self.isDeleted, fieldNumber: 6)
    }
    if self.starredModified != 0 {
      try visitor.visitSingularInt64Field(value: self.starredModified, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_StarredEpisode, rhs: Api_StarredEpisode) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.podcastUuid != rhs.podcastUuid {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.playingStatus != rhs.playingStatus {return false}
    if lhs.playedUpTo != rhs.playedUpTo {return false}
    if lhs.isDeleted != rhs.isDeleted {return false}
    if lhs.starredModified != rhs.starredModified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PlaylistSyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaylistSyncResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "is_deleted"),
    3: .same(proto: "title"),
    4: .standard(proto: "audio_video"),
    5: .standard(proto: "not_downloaded"),
    6: .same(proto: "downloaded"),
    7: .same(proto: "downloading"),
    8: .same(proto: "finished"),
    9: .standard(proto: "partially_played"),
    10: .same(proto: "unplayed"),
    11: .same(proto: "starred"),
    12: .same(proto: "manual"),
    13: .standard(proto: "sort_position"),
    14: .standard(proto: "sort_type"),
    15: .standard(proto: "icon_id"),
    16: .standard(proto: "all_podcasts"),
    17: .standard(proto: "filter_hours"),
    18: .standard(proto: "podcast_uuids"),
    19: .standard(proto: "episode_uuids"),
    20: .standard(proto: "original_uuid"),
    21: .standard(proto: "filter_duration"),
    22: .standard(proto: "longer_than"),
    23: .standard(proto: "shorter_than"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _title: String = String()
    var _audioVideo: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _notDownloaded: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _downloaded: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _downloading: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _finished: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _partiallyPlayed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _unplayed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _starred: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _manual: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _sortType: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _iconID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _allPodcasts: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _filterHours: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _podcastUuids: String = String()
    var _episodeUuids: String = String()
    var _originalUuid: String = String()
    var _filterDuration: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _longerThan: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _shorterThan: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _isDeleted = source._isDeleted
      _title = source._title
      _audioVideo = source._audioVideo
      _notDownloaded = source._notDownloaded
      _downloaded = source._downloaded
      _downloading = source._downloading
      _finished = source._finished
      _partiallyPlayed = source._partiallyPlayed
      _unplayed = source._unplayed
      _starred = source._starred
      _manual = source._manual
      _sortPosition = source._sortPosition
      _sortType = source._sortType
      _iconID = source._iconID
      _allPodcasts = source._allPodcasts
      _filterHours = source._filterHours
      _podcastUuids = source._podcastUuids
      _episodeUuids = source._episodeUuids
      _originalUuid = source._originalUuid
      _filterDuration = source._filterDuration
      _longerThan = source._longerThan
      _shorterThan = source._shorterThan
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._isDeleted) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._audioVideo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._notDownloaded) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._downloaded) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._downloading) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._finished) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._partiallyPlayed) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._unplayed) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._starred) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._manual) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._sortPosition) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._sortType) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._iconID) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._allPodcasts) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._filterHours) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._podcastUuids) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._episodeUuids) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._originalUuid) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._filterDuration) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._longerThan) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._shorterThan) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      try { if let v = _storage._isDeleted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 3)
      }
      try { if let v = _storage._audioVideo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._notDownloaded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._downloaded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._downloading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._finished {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._partiallyPlayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._unplayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._starred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._manual {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._sortPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._sortType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._iconID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._allPodcasts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._filterHours {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._podcastUuids.isEmpty {
        try visitor.visitSingularStringField(value: _storage._podcastUuids, fieldNumber: 18)
      }
      if !_storage._episodeUuids.isEmpty {
        try visitor.visitSingularStringField(value: _storage._episodeUuids, fieldNumber: 19)
      }
      if !_storage._originalUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._originalUuid, fieldNumber: 20)
      }
      try { if let v = _storage._filterDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._longerThan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._shorterThan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PlaylistSyncResponse, rhs: Api_PlaylistSyncResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._audioVideo != rhs_storage._audioVideo {return false}
        if _storage._notDownloaded != rhs_storage._notDownloaded {return false}
        if _storage._downloaded != rhs_storage._downloaded {return false}
        if _storage._downloading != rhs_storage._downloading {return false}
        if _storage._finished != rhs_storage._finished {return false}
        if _storage._partiallyPlayed != rhs_storage._partiallyPlayed {return false}
        if _storage._unplayed != rhs_storage._unplayed {return false}
        if _storage._starred != rhs_storage._starred {return false}
        if _storage._manual != rhs_storage._manual {return false}
        if _storage._sortPosition != rhs_storage._sortPosition {return false}
        if _storage._sortType != rhs_storage._sortType {return false}
        if _storage._iconID != rhs_storage._iconID {return false}
        if _storage._allPodcasts != rhs_storage._allPodcasts {return false}
        if _storage._filterHours != rhs_storage._filterHours {return false}
        if _storage._podcastUuids != rhs_storage._podcastUuids {return false}
        if _storage._episodeUuids != rhs_storage._episodeUuids {return false}
        if _storage._originalUuid != rhs_storage._originalUuid {return false}
        if _storage._filterDuration != rhs_storage._filterDuration {return false}
        if _storage._longerThan != rhs_storage._longerThan {return false}
        if _storage._shorterThan != rhs_storage._shorterThan {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CheckEligibleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckEligibleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "android"),
    2: .same(proto: "apple"),
    3: .same(proto: "web"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api_SubscriptionsPurchaseAndroidRequest?
        var hadOneofValue = false
        if let current = self.storeReceipt {
          hadOneofValue = true
          if case .android(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.storeReceipt = .android(v)
        }
      }()
      case 2: try {
        var v: Api_SubscriptionsPurchaseAppleRequest?
        var hadOneofValue = false
        if let current = self.storeReceipt {
          hadOneofValue = true
          if case .apple(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.storeReceipt = .apple(v)
        }
      }()
      case 3: try {
        var v: Api_SubscriptionsPurchaseWebRequest?
        var hadOneofValue = false
        if let current = self.storeReceipt {
          hadOneofValue = true
          if case .web(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.storeReceipt = .web(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.storeReceipt {
    case .android?: try {
      guard case .android(let v)? = self.storeReceipt else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .apple?: try {
      guard case .apple(let v)? = self.storeReceipt else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .web?: try {
      guard case .web(let v)? = self.storeReceipt else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_CheckEligibleRequest, rhs: Api_CheckEligibleRequest) -> Bool {
    if lhs.storeReceipt != rhs.storeReceipt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CheckEligibleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckEligibleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "eligible"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.eligible) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platform != 0 {
      try visitor.visitSingularInt32Field(value: self.platform, fieldNumber: 1)
    }
    if self.eligible != false {
      try visitor.visitSingularBoolField(value: self.eligible, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_CheckEligibleResponse, rhs: Api_CheckEligibleResponse) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.eligible != rhs.eligible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SubscriptionsPurchaseAndroidRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionsPurchaseAndroidRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "purchaseToken"),
    2: .same(proto: "sku"),
    3: .same(proto: "newsletterOptIn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.purchaseToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sku) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.newsletterOptIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.purchaseToken.isEmpty {
      try visitor.visitSingularStringField(value: self.purchaseToken, fieldNumber: 1)
    }
    if !self.sku.isEmpty {
      try visitor.visitSingularStringField(value: self.sku, fieldNumber: 2)
    }
    if self.newsletterOptIn != false {
      try visitor.visitSingularBoolField(value: self.newsletterOptIn, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SubscriptionsPurchaseAndroidRequest, rhs: Api_SubscriptionsPurchaseAndroidRequest) -> Bool {
    if lhs.purchaseToken != rhs.purchaseToken {return false}
    if lhs.sku != rhs.sku {return false}
    if lhs.newsletterOptIn != rhs.newsletterOptIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SubscriptionsPurchaseAppleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionsPurchaseAppleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receipt"),
    2: .same(proto: "newsletterOptIn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.receipt) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.newsletterOptIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.receipt.isEmpty {
      try visitor.visitSingularStringField(value: self.receipt, fieldNumber: 1)
    }
    if self.newsletterOptIn != false {
      try visitor.visitSingularBoolField(value: self.newsletterOptIn, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SubscriptionsPurchaseAppleRequest, rhs: Api_SubscriptionsPurchaseAppleRequest) -> Bool {
    if lhs.receipt != rhs.receipt {return false}
    if lhs.newsletterOptIn != rhs.newsletterOptIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SubscriptionsPurchaseWebRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionsPurchaseWebRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionId"),
    2: .same(proto: "email"),
    3: .same(proto: "paddleUserId"),
    4: .same(proto: "productId"),
    5: .same(proto: "newsletterOptIn"),
    6: .same(proto: "subscriptionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.paddleUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.productID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.newsletterOptIn) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.paddleUserID != 0 {
      try visitor.visitSingularInt64Field(value: self.paddleUserID, fieldNumber: 3)
    }
    if !self.productID.isEmpty {
      try visitor.visitSingularStringField(value: self.productID, fieldNumber: 4)
    }
    if self.newsletterOptIn != false {
      try visitor.visitSingularBoolField(value: self.newsletterOptIn, fieldNumber: 5)
    }
    if self.subscriptionID != 0 {
      try visitor.visitSingularInt64Field(value: self.subscriptionID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SubscriptionsPurchaseWebRequest, rhs: Api_SubscriptionsPurchaseWebRequest) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.paddleUserID != rhs.paddleUserID {return false}
    if lhs.productID != rhs.productID {return false}
    if lhs.newsletterOptIn != rhs.newsletterOptIn {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SubscriptionsWebStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionsWebStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "monthly"),
    2: .same(proto: "yearly"),
    3: .same(proto: "trial"),
    4: .same(proto: "webStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.monthly) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.yearly) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.trial) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.webStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.monthly != 0 {
      try visitor.visitSingularInt32Field(value: self.monthly, fieldNumber: 1)
    }
    if self.yearly != 0 {
      try visitor.visitSingularInt32Field(value: self.yearly, fieldNumber: 2)
    }
    if self.trial != 0 {
      try visitor.visitSingularInt32Field(value: self.trial, fieldNumber: 3)
    }
    if self.webStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.webStatus, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SubscriptionsWebStatusResponse, rhs: Api_SubscriptionsWebStatusResponse) -> Bool {
    if lhs.monthly != rhs.monthly {return false}
    if lhs.yearly != rhs.yearly {return false}
    if lhs.trial != rhs.trial {return false}
    if lhs.webStatus != rhs.webStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .same(proto: "type"),
    3: .same(proto: "frequency"),
    4: .same(proto: "autoRenewing"),
    5: .same(proto: "expiryDate"),
    7: .same(proto: "cancelUrl"),
    8: .same(proto: "updateUrl"),
    9: .same(proto: "web"),
    10: .same(proto: "plan"),
    11: .same(proto: "index"),
    12: .standard(proto: "gift_days"),
    13: .same(proto: "paid"),
    14: .same(proto: "webStatus"),
    15: .standard(proto: "bundle_uuid"),
    16: .same(proto: "podcasts"),
    17: .same(proto: "eligible"),
  ]

  fileprivate class _StorageClass {
    var _platform: Int32 = 0
    var _type: Int32 = 0
    var _frequency: Int32 = 0
    var _autoRenewing: Bool = false
    var _expiryDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _cancelURL: String = String()
    var _updateURL: String = String()
    var _web: Api_SubscriptionsWebStatusResponse? = nil
    var _plan: String = String()
    var _index: Int32 = 0
    var _giftDays: Int32 = 0
    var _paid: Int32 = 0
    var _webStatus: Int32 = 0
    var _bundleUuid: String = String()
    var _podcasts: [Api_PodcastPair] = []
    var _eligible: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _platform = source._platform
      _type = source._type
      _frequency = source._frequency
      _autoRenewing = source._autoRenewing
      _expiryDate = source._expiryDate
      _cancelURL = source._cancelURL
      _updateURL = source._updateURL
      _web = source._web
      _plan = source._plan
      _index = source._index
      _giftDays = source._giftDays
      _paid = source._paid
      _webStatus = source._webStatus
      _bundleUuid = source._bundleUuid
      _podcasts = source._podcasts
      _eligible = source._eligible
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._platform) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._frequency) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._autoRenewing) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._expiryDate) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._cancelURL) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._updateURL) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._web) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._plan) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._index) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._giftDays) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._paid) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._webStatus) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._bundleUuid) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._podcasts) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._eligible) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._platform != 0 {
        try visitor.visitSingularInt32Field(value: _storage._platform, fieldNumber: 1)
      }
      if _storage._type != 0 {
        try visitor.visitSingularInt32Field(value: _storage._type, fieldNumber: 2)
      }
      if _storage._frequency != 0 {
        try visitor.visitSingularInt32Field(value: _storage._frequency, fieldNumber: 3)
      }
      if _storage._autoRenewing != false {
        try visitor.visitSingularBoolField(value: _storage._autoRenewing, fieldNumber: 4)
      }
      try { if let v = _storage._expiryDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._cancelURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cancelURL, fieldNumber: 7)
      }
      if !_storage._updateURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updateURL, fieldNumber: 8)
      }
      try { if let v = _storage._web {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._plan.isEmpty {
        try visitor.visitSingularStringField(value: _storage._plan, fieldNumber: 10)
      }
      if _storage._index != 0 {
        try visitor.visitSingularInt32Field(value: _storage._index, fieldNumber: 11)
      }
      if _storage._giftDays != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftDays, fieldNumber: 12)
      }
      if _storage._paid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._paid, fieldNumber: 13)
      }
      if _storage._webStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._webStatus, fieldNumber: 14)
      }
      if !_storage._bundleUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bundleUuid, fieldNumber: 15)
      }
      if !_storage._podcasts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._podcasts, fieldNumber: 16)
      }
      if _storage._eligible != false {
        try visitor.visitSingularBoolField(value: _storage._eligible, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SubscriptionResponse, rhs: Api_SubscriptionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._autoRenewing != rhs_storage._autoRenewing {return false}
        if _storage._expiryDate != rhs_storage._expiryDate {return false}
        if _storage._cancelURL != rhs_storage._cancelURL {return false}
        if _storage._updateURL != rhs_storage._updateURL {return false}
        if _storage._web != rhs_storage._web {return false}
        if _storage._plan != rhs_storage._plan {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._giftDays != rhs_storage._giftDays {return false}
        if _storage._paid != rhs_storage._paid {return false}
        if _storage._webStatus != rhs_storage._webStatus {return false}
        if _storage._bundleUuid != rhs_storage._bundleUuid {return false}
        if _storage._podcasts != rhs_storage._podcasts {return false}
        if _storage._eligible != rhs_storage._eligible {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PodcastPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodcastPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterPodcastUuid"),
    2: .same(proto: "userPodcastUuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.masterPodcastUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userPodcastUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.masterPodcastUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.masterPodcastUuid, fieldNumber: 1)
    }
    if !self.userPodcastUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.userPodcastUuid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PodcastPair, rhs: Api_PodcastPair) -> Bool {
    if lhs.masterPodcastUuid != rhs.masterPodcastUuid {return false}
    if lhs.userPodcastUuid != rhs.userPodcastUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SubscriptionsStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionsStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paid"),
    2: .same(proto: "platform"),
    3: .same(proto: "expiryDate"),
    4: .same(proto: "autoRenewing"),
    5: .same(proto: "giftDays"),
    6: .same(proto: "cancelUrl"),
    7: .same(proto: "updateUrl"),
    8: .same(proto: "frequency"),
    9: .same(proto: "web"),
    10: .same(proto: "subscriptions"),
    11: .same(proto: "type"),
    12: .same(proto: "index"),
    13: .same(proto: "webStatus"),
  ]

  fileprivate class _StorageClass {
    var _paid: Int32 = 0
    var _platform: Int32 = 0
    var _expiryDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _autoRenewing: Bool = false
    var _giftDays: Int32 = 0
    var _cancelURL: String = String()
    var _updateURL: String = String()
    var _frequency: Int32 = 0
    var _web: Api_SubscriptionsWebStatusResponse? = nil
    var _subscriptions: [Api_SubscriptionResponse] = []
    var _type: Int32 = 0
    var _index: Int32 = 0
    var _webStatus: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paid = source._paid
      _platform = source._platform
      _expiryDate = source._expiryDate
      _autoRenewing = source._autoRenewing
      _giftDays = source._giftDays
      _cancelURL = source._cancelURL
      _updateURL = source._updateURL
      _frequency = source._frequency
      _web = source._web
      _subscriptions = source._subscriptions
      _type = source._type
      _index = source._index
      _webStatus = source._webStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._paid) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._platform) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._expiryDate) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._autoRenewing) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._giftDays) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._cancelURL) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._updateURL) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._frequency) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._web) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._subscriptions) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._type) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._index) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._webStatus) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._paid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._paid, fieldNumber: 1)
      }
      if _storage._platform != 0 {
        try visitor.visitSingularInt32Field(value: _storage._platform, fieldNumber: 2)
      }
      try { if let v = _storage._expiryDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._autoRenewing != false {
        try visitor.visitSingularBoolField(value: _storage._autoRenewing, fieldNumber: 4)
      }
      if _storage._giftDays != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftDays, fieldNumber: 5)
      }
      if !_storage._cancelURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cancelURL, fieldNumber: 6)
      }
      if !_storage._updateURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updateURL, fieldNumber: 7)
      }
      if _storage._frequency != 0 {
        try visitor.visitSingularInt32Field(value: _storage._frequency, fieldNumber: 8)
      }
      try { if let v = _storage._web {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._subscriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subscriptions, fieldNumber: 10)
      }
      if _storage._type != 0 {
        try visitor.visitSingularInt32Field(value: _storage._type, fieldNumber: 11)
      }
      if _storage._index != 0 {
        try visitor.visitSingularInt32Field(value: _storage._index, fieldNumber: 12)
      }
      if _storage._webStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._webStatus, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SubscriptionsStatusResponse, rhs: Api_SubscriptionsStatusResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paid != rhs_storage._paid {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._expiryDate != rhs_storage._expiryDate {return false}
        if _storage._autoRenewing != rhs_storage._autoRenewing {return false}
        if _storage._giftDays != rhs_storage._giftDays {return false}
        if _storage._cancelURL != rhs_storage._cancelURL {return false}
        if _storage._updateURL != rhs_storage._updateURL {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._web != rhs_storage._web {return false}
        if _storage._subscriptions != rhs_storage._subscriptions {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._webStatus != rhs_storage._webStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CancelUserSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelUserSubscriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bundleUuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleUuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_CancelUserSubscriptionRequest, rhs: Api_CancelUserSubscriptionRequest) -> Bool {
    if lhs.bundleUuid != rhs.bundleUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "datetime"),
    3: .same(proto: "v"),
    4: .same(proto: "av"),
    5: .same(proto: "ac"),
    6: .same(proto: "h"),
    7: .same(proto: "dt"),
    8: .same(proto: "c"),
    9: .same(proto: "l"),
    10: .same(proto: "m"),
    11: .same(proto: "email"),
    12: .same(proto: "password"),
    13: .same(proto: "token"),
    14: .standard(proto: "device_utc_time_ms"),
    15: .same(proto: "data"),
    16: .same(proto: "message"),
    17: .standard(proto: "last_modified"),
  ]

  fileprivate class _StorageClass {
    var _device: String = String()
    var _datetime: String = String()
    var _v: String = String()
    var _av: String = String()
    var _ac: String = String()
    var _h: String = String()
    var _dt: String = String()
    var _c: String = String()
    var _l: String = String()
    var _m: String = String()
    var _email: String = String()
    var _password: String = String()
    var _token: String = String()
    var _deviceUtcTimeMs: String = String()
    var _data: String = String()
    var _message: String = String()
    var _lastModified: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _device = source._device
      _datetime = source._datetime
      _v = source._v
      _av = source._av
      _ac = source._ac
      _h = source._h
      _dt = source._dt
      _c = source._c
      _l = source._l
      _m = source._m
      _email = source._email
      _password = source._password
      _token = source._token
      _deviceUtcTimeMs = source._deviceUtcTimeMs
      _data = source._data
      _message = source._message
      _lastModified = source._lastModified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._device) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._datetime) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._v) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._av) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._ac) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._h) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._dt) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._c) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._l) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._m) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._password) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._deviceUtcTimeMs) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._data) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._lastModified) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._device.isEmpty {
        try visitor.visitSingularStringField(value: _storage._device, fieldNumber: 1)
      }
      if !_storage._datetime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._datetime, fieldNumber: 2)
      }
      if !_storage._v.isEmpty {
        try visitor.visitSingularStringField(value: _storage._v, fieldNumber: 3)
      }
      if !_storage._av.isEmpty {
        try visitor.visitSingularStringField(value: _storage._av, fieldNumber: 4)
      }
      if !_storage._ac.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ac, fieldNumber: 5)
      }
      if !_storage._h.isEmpty {
        try visitor.visitSingularStringField(value: _storage._h, fieldNumber: 6)
      }
      if !_storage._dt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dt, fieldNumber: 7)
      }
      if !_storage._c.isEmpty {
        try visitor.visitSingularStringField(value: _storage._c, fieldNumber: 8)
      }
      if !_storage._l.isEmpty {
        try visitor.visitSingularStringField(value: _storage._l, fieldNumber: 9)
      }
      if !_storage._m.isEmpty {
        try visitor.visitSingularStringField(value: _storage._m, fieldNumber: 10)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 11)
      }
      if !_storage._password.isEmpty {
        try visitor.visitSingularStringField(value: _storage._password, fieldNumber: 12)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 13)
      }
      if !_storage._deviceUtcTimeMs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deviceUtcTimeMs, fieldNumber: 14)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularStringField(value: _storage._data, fieldNumber: 15)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 16)
      }
      if !_storage._lastModified.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastModified, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacyRequest, rhs: Api_LegacyRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._device != rhs_storage._device {return false}
        if _storage._datetime != rhs_storage._datetime {return false}
        if _storage._v != rhs_storage._v {return false}
        if _storage._av != rhs_storage._av {return false}
        if _storage._ac != rhs_storage._ac {return false}
        if _storage._h != rhs_storage._h {return false}
        if _storage._dt != rhs_storage._dt {return false}
        if _storage._c != rhs_storage._c {return false}
        if _storage._l != rhs_storage._l {return false}
        if _storage._m != rhs_storage._m {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._password != rhs_storage._password {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._deviceUtcTimeMs != rhs_storage._deviceUtcTimeMs {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._lastModified != rhs_storage._lastModified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "token"),
    3: .same(proto: "copyright"),
    4: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.copyright) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.copyright.isEmpty {
      try visitor.visitSingularStringField(value: self.copyright, fieldNumber: 3)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacyResponse, rhs: Api_LegacyResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.token != rhs.token {return false}
    if lhs.copyright != rhs.copyright {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_utc_time_ms"),
    2: .standard(proto: "last_modified"),
    3: .same(proto: "country"),
    4: .standard(proto: "device_id"),
    5: .same(proto: "records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.deviceUtcTimeMs) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastModified) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUtcTimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.deviceUtcTimeMs, fieldNumber: 1)
    }
    if self.lastModified != 0 {
      try visitor.visitSingularInt64Field(value: self.lastModified, fieldNumber: 2)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 3)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 4)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncUpdateRequest, rhs: Api_SyncUpdateRequest) -> Bool {
    if lhs.deviceUtcTimeMs != rhs.deviceUtcTimeMs {return false}
    if lhs.lastModified != rhs.lastModified {return false}
    if lhs.country != rhs.country {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_modified"),
    2: .same(proto: "records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lastModified) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastModified != 0 {
      try visitor.visitSingularInt64Field(value: self.lastModified, fieldNumber: 1)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncUpdateResponse, rhs: Api_SyncUpdateResponse) -> Bool {
    if lhs.lastModified != rhs.lastModified {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podcast"),
    2: .same(proto: "episode"),
    3: .same(proto: "playlist"),
    4: .same(proto: "device"),
    5: .same(proto: "folder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api_SyncUserPodcast?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .podcast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .podcast(v)
        }
      }()
      case 2: try {
        var v: Api_SyncUserEpisode?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .episode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .episode(v)
        }
      }()
      case 3: try {
        var v: Api_SyncUserPlaylist?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .playlist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .playlist(v)
        }
      }()
      case 4: try {
        var v: Api_SyncUserDevice?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .device(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .device(v)
        }
      }()
      case 5: try {
        var v: Api_SyncUserFolder?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .folder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .folder(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.record {
    case .podcast?: try {
      guard case .podcast(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .episode?: try {
      guard case .episode(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .playlist?: try {
      guard case .playlist(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .device?: try {
      guard case .device(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .folder?: try {
      guard case .folder(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_Record, rhs: Api_Record) -> Bool {
    if lhs.record != rhs.record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncUserPodcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncUserPodcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "is_deleted"),
    3: .same(proto: "subscribed"),
    4: .standard(proto: "auto_start_from"),
    5: .standard(proto: "episodes_sort_order"),
    6: .standard(proto: "auto_skip_last"),
    7: .standard(proto: "folder_uuid"),
    8: .standard(proto: "sort_position"),
    9: .standard(proto: "date_added"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._isDeleted) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._subscribed) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._autoStartFrom) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._episodesSortOrder) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._autoSkipLast) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._folderUuid) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._sortPosition) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._dateAdded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    try { if let v = self._isDeleted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._subscribed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._autoStartFrom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._episodesSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._autoSkipLast {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._folderUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._sortPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._dateAdded {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncUserPodcast, rhs: Api_SyncUserPodcast) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs._isDeleted != rhs._isDeleted {return false}
    if lhs._subscribed != rhs._subscribed {return false}
    if lhs._autoStartFrom != rhs._autoStartFrom {return false}
    if lhs._episodesSortOrder != rhs._episodesSortOrder {return false}
    if lhs._autoSkipLast != rhs._autoSkipLast {return false}
    if lhs._folderUuid != rhs._folderUuid {return false}
    if lhs._sortPosition != rhs._sortPosition {return false}
    if lhs._dateAdded != rhs._dateAdded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncUserEpisode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncUserEpisode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "podcast_uuid"),
    3: .standard(proto: "is_deleted"),
    4: .standard(proto: "is_deleted_modified"),
    5: .same(proto: "duration"),
    6: .standard(proto: "duration_modified"),
    7: .standard(proto: "playing_status"),
    8: .standard(proto: "playing_status_modified"),
    9: .standard(proto: "played_up_to"),
    10: .standard(proto: "played_up_to_modified"),
    11: .same(proto: "starred"),
    12: .standard(proto: "starred_modified"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podcastUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._isDeleted) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._isDeletedModified) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._durationModified) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._playingStatus) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._playingStatusModified) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._playedUpTo) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._playedUpToModified) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._starred) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._starredModified) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.podcastUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastUuid, fieldNumber: 2)
    }
    try { if let v = self._isDeleted {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isDeletedModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._durationModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._playingStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._playingStatusModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._playedUpTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._playedUpToModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._starred {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._starredModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncUserEpisode, rhs: Api_SyncUserEpisode) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.podcastUuid != rhs.podcastUuid {return false}
    if lhs._isDeleted != rhs._isDeleted {return false}
    if lhs._isDeletedModified != rhs._isDeletedModified {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._durationModified != rhs._durationModified {return false}
    if lhs._playingStatus != rhs._playingStatus {return false}
    if lhs._playingStatusModified != rhs._playingStatusModified {return false}
    if lhs._playedUpTo != rhs._playedUpTo {return false}
    if lhs._playedUpToModified != rhs._playedUpToModified {return false}
    if lhs._starred != rhs._starred {return false}
    if lhs._starredModified != rhs._starredModified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncUserDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncUserDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "device_type"),
    3: .standard(proto: "times_started_at"),
    4: .standard(proto: "time_silence_removal"),
    5: .standard(proto: "time_variable_speed"),
    6: .standard(proto: "time_intro_skipping"),
    7: .standard(proto: "time_skipping"),
    8: .standard(proto: "time_listened"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deviceType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timesStartedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeSilenceRemoval) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._timeVariableSpeed) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timeIntroSkipping) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._timeSkipping) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._timeListened) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deviceType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timesStartedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timeSilenceRemoval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timeVariableSpeed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timeIntroSkipping {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._timeSkipping {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._timeListened {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncUserDevice, rhs: Api_SyncUserDevice) -> Bool {
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs._deviceType != rhs._deviceType {return false}
    if lhs._timesStartedAt != rhs._timesStartedAt {return false}
    if lhs._timeSilenceRemoval != rhs._timeSilenceRemoval {return false}
    if lhs._timeVariableSpeed != rhs._timeVariableSpeed {return false}
    if lhs._timeIntroSkipping != rhs._timeIntroSkipping {return false}
    if lhs._timeSkipping != rhs._timeSkipping {return false}
    if lhs._timeListened != rhs._timeListened {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncUserPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncUserPlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "is_deleted"),
    3: .same(proto: "title"),
    4: .standard(proto: "all_podcasts"),
    5: .standard(proto: "podcast_uuids"),
    6: .standard(proto: "episode_uuids"),
    7: .standard(proto: "audio_video"),
    8: .standard(proto: "not_downloaded"),
    9: .same(proto: "downloaded"),
    10: .same(proto: "downloading"),
    11: .same(proto: "finished"),
    12: .standard(proto: "partially_played"),
    13: .same(proto: "unplayed"),
    14: .same(proto: "starred"),
    15: .same(proto: "manual"),
    16: .standard(proto: "sort_position"),
    17: .standard(proto: "sort_type"),
    18: .standard(proto: "icon_id"),
    19: .standard(proto: "filter_hours"),
    20: .standard(proto: "original_uuid"),
    21: .standard(proto: "filter_duration"),
    22: .standard(proto: "longer_than"),
    23: .standard(proto: "shorter_than"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _title: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _allPodcasts: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _podcastUuids: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _episodeUuids: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _audioVideo: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _notDownloaded: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _downloaded: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _downloading: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _finished: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _partiallyPlayed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _unplayed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _starred: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _manual: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _sortType: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _iconID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _filterHours: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _originalUuid: String = String()
    var _filterDuration: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _longerThan: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _shorterThan: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _isDeleted = source._isDeleted
      _title = source._title
      _allPodcasts = source._allPodcasts
      _podcastUuids = source._podcastUuids
      _episodeUuids = source._episodeUuids
      _audioVideo = source._audioVideo
      _notDownloaded = source._notDownloaded
      _downloaded = source._downloaded
      _downloading = source._downloading
      _finished = source._finished
      _partiallyPlayed = source._partiallyPlayed
      _unplayed = source._unplayed
      _starred = source._starred
      _manual = source._manual
      _sortPosition = source._sortPosition
      _sortType = source._sortType
      _iconID = source._iconID
      _filterHours = source._filterHours
      _originalUuid = source._originalUuid
      _filterDuration = source._filterDuration
      _longerThan = source._longerThan
      _shorterThan = source._shorterThan
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._isDeleted) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._title) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._allPodcasts) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._podcastUuids) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._episodeUuids) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._audioVideo) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._notDownloaded) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._downloaded) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._downloading) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._finished) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._partiallyPlayed) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._unplayed) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._starred) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._manual) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._sortPosition) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._sortType) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._iconID) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._filterHours) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._originalUuid) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._filterDuration) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._longerThan) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._shorterThan) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      try { if let v = _storage._isDeleted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._allPodcasts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._podcastUuids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._episodeUuids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._audioVideo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._notDownloaded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._downloaded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._downloading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._finished {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._partiallyPlayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._unplayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._starred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._manual {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._sortPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._sortType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._iconID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._filterHours {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._originalUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._originalUuid, fieldNumber: 20)
      }
      try { if let v = _storage._filterDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._longerThan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._shorterThan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncUserPlaylist, rhs: Api_SyncUserPlaylist) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._allPodcasts != rhs_storage._allPodcasts {return false}
        if _storage._podcastUuids != rhs_storage._podcastUuids {return false}
        if _storage._episodeUuids != rhs_storage._episodeUuids {return false}
        if _storage._audioVideo != rhs_storage._audioVideo {return false}
        if _storage._notDownloaded != rhs_storage._notDownloaded {return false}
        if _storage._downloaded != rhs_storage._downloaded {return false}
        if _storage._downloading != rhs_storage._downloading {return false}
        if _storage._finished != rhs_storage._finished {return false}
        if _storage._partiallyPlayed != rhs_storage._partiallyPlayed {return false}
        if _storage._unplayed != rhs_storage._unplayed {return false}
        if _storage._starred != rhs_storage._starred {return false}
        if _storage._manual != rhs_storage._manual {return false}
        if _storage._sortPosition != rhs_storage._sortPosition {return false}
        if _storage._sortType != rhs_storage._sortType {return false}
        if _storage._iconID != rhs_storage._iconID {return false}
        if _storage._filterHours != rhs_storage._filterHours {return false}
        if _storage._originalUuid != rhs_storage._originalUuid {return false}
        if _storage._filterDuration != rhs_storage._filterDuration {return false}
        if _storage._longerThan != rhs_storage._longerThan {return false}
        if _storage._shorterThan != rhs_storage._shorterThan {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SyncUserFolder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncUserFolder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "folder_uuid"),
    2: .standard(proto: "is_deleted"),
    3: .same(proto: "name"),
    4: .same(proto: "color"),
    5: .standard(proto: "sort_position"),
    6: .standard(proto: "podcasts_sort_type"),
    7: .standard(proto: "date_added"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.folderUuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isDeleted) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.color) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.sortPosition) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.podcastsSortType) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._dateAdded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.folderUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.folderUuid, fieldNumber: 1)
    }
    if self.isDeleted != false {
      try visitor.visitSingularBoolField(value: self.isDeleted, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.color != 0 {
      try visitor.visitSingularInt32Field(value: self.color, fieldNumber: 4)
    }
    if self.sortPosition != 0 {
      try visitor.visitSingularInt32Field(value: self.sortPosition, fieldNumber: 5)
    }
    if self.podcastsSortType != 0 {
      try visitor.visitSingularInt32Field(value: self.podcastsSortType, fieldNumber: 6)
    }
    try { if let v = self._dateAdded {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SyncUserFolder, rhs: Api_SyncUserFolder) -> Bool {
    if lhs.folderUuid != rhs.folderUuid {return false}
    if lhs.isDeleted != rhs.isDeleted {return false}
    if lhs.name != rhs.name {return false}
    if lhs.color != rhs.color {return false}
    if lhs.sortPosition != rhs.sortPosition {return false}
    if lhs.podcastsSortType != rhs.podcastsSortType {return false}
    if lhs._dateAdded != rhs._dateAdded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacySyncData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacySyncData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "records"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacySyncData, rhs: Api_LegacySyncData) -> Bool {
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacySyncRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacySyncRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacySyncRecord, rhs: Api_LegacySyncRecord) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacyRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacyRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "user_podcast_uuid"),
    3: .standard(proto: "episode_uuid"),
    4: .standard(proto: "podcast_uuid"),
    5: .standard(proto: "is_deleted"),
    6: .standard(proto: "is_deleted_modified"),
    7: .same(proto: "duration"),
    8: .standard(proto: "duration_modified"),
    9: .standard(proto: "playing_status"),
    10: .standard(proto: "playing_status_modified"),
    11: .standard(proto: "played_up_to"),
    12: .standard(proto: "played_up_to_modified"),
    13: .same(proto: "starred"),
    14: .standard(proto: "starred_modified"),
    15: .standard(proto: "times_started_at"),
    16: .standard(proto: "time_silence_removal"),
    17: .standard(proto: "time_variable_speed"),
    18: .standard(proto: "time_intro_skipping"),
    19: .standard(proto: "time_skipping"),
    20: .standard(proto: "time_listened"),
    21: .standard(proto: "auto_start_from"),
    22: .same(proto: "subscribed"),
    23: .same(proto: "title"),
    24: .standard(proto: "all_podcasts"),
    25: .standard(proto: "podcast_uuids"),
    26: .standard(proto: "episode_uuids"),
    27: .standard(proto: "audio_video"),
    28: .standard(proto: "not_downloaded"),
    29: .same(proto: "downloaded"),
    30: .same(proto: "downloading"),
    31: .same(proto: "finished"),
    32: .standard(proto: "partially_played"),
    33: .same(proto: "unplayed"),
    34: .same(proto: "manual"),
    35: .standard(proto: "sort_position"),
    36: .standard(proto: "sort_type"),
    37: .standard(proto: "icon_id"),
    38: .standard(proto: "filter_hours"),
    39: .standard(proto: "auto_skip_last"),
    40: .standard(proto: "filter_duration"),
    41: .standard(proto: "longer_than"),
    42: .standard(proto: "shorter_than"),
    43: .standard(proto: "folder_uuid"),
    44: .same(proto: "name"),
    45: .same(proto: "color"),
    46: .standard(proto: "podcasts_sort_type"),
    47: .standard(proto: "date_added"),
  ]

  fileprivate class _StorageClass {
    var _uuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _userPodcastUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _episodeUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _podcastUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _isDeleted: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _isDeletedModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _duration: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _durationModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _playingStatus: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _playingStatusModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _playedUpTo: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _playedUpToModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _starred: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _starredModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _timesStartedAt: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _timeSilenceRemoval: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _timeVariableSpeed: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _timeIntroSkipping: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _timeSkipping: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _timeListened: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _autoStartFrom: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _subscribed: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _title: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _allPodcasts: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _podcastUuids: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _episodeUuids: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _audioVideo: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _notDownloaded: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _downloaded: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _downloading: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _finished: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _partiallyPlayed: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _unplayed: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _manual: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _sortType: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _iconID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _filterHours: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _autoSkipLast: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _filterDuration: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _longerThan: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _shorterThan: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _folderUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _name: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _color: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _podcastsSortType: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _userPodcastUuid = source._userPodcastUuid
      _episodeUuid = source._episodeUuid
      _podcastUuid = source._podcastUuid
      _isDeleted = source._isDeleted
      _isDeletedModified = source._isDeletedModified
      _duration = source._duration
      _durationModified = source._durationModified
      _playingStatus = source._playingStatus
      _playingStatusModified = source._playingStatusModified
      _playedUpTo = source._playedUpTo
      _playedUpToModified = source._playedUpToModified
      _starred = source._starred
      _starredModified = source._starredModified
      _timesStartedAt = source._timesStartedAt
      _timeSilenceRemoval = source._timeSilenceRemoval
      _timeVariableSpeed = source._timeVariableSpeed
      _timeIntroSkipping = source._timeIntroSkipping
      _timeSkipping = source._timeSkipping
      _timeListened = source._timeListened
      _autoStartFrom = source._autoStartFrom
      _subscribed = source._subscribed
      _title = source._title
      _allPodcasts = source._allPodcasts
      _podcastUuids = source._podcastUuids
      _episodeUuids = source._episodeUuids
      _audioVideo = source._audioVideo
      _notDownloaded = source._notDownloaded
      _downloaded = source._downloaded
      _downloading = source._downloading
      _finished = source._finished
      _partiallyPlayed = source._partiallyPlayed
      _unplayed = source._unplayed
      _manual = source._manual
      _sortPosition = source._sortPosition
      _sortType = source._sortType
      _iconID = source._iconID
      _filterHours = source._filterHours
      _autoSkipLast = source._autoSkipLast
      _filterDuration = source._filterDuration
      _longerThan = source._longerThan
      _shorterThan = source._shorterThan
      _folderUuid = source._folderUuid
      _name = source._name
      _color = source._color
      _podcastsSortType = source._podcastsSortType
      _dateAdded = source._dateAdded
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userPodcastUuid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._episodeUuid) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._podcastUuid) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._isDeleted) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._isDeletedModified) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._duration) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._durationModified) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._playingStatus) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._playingStatusModified) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._playedUpTo) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._playedUpToModified) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._starred) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._starredModified) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._timesStartedAt) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._timeSilenceRemoval) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._timeVariableSpeed) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._timeIntroSkipping) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._timeSkipping) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._timeListened) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._autoStartFrom) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._subscribed) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._title) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._allPodcasts) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._podcastUuids) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._episodeUuids) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._audioVideo) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._notDownloaded) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._downloaded) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._downloading) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._finished) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._partiallyPlayed) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._unplayed) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._manual) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._sortPosition) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._sortType) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._iconID) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._filterHours) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._autoSkipLast) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._filterDuration) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._longerThan) }()
        case 42: try { try decoder.decodeSingularMessageField(value: &_storage._shorterThan) }()
        case 43: try { try decoder.decodeSingularMessageField(value: &_storage._folderUuid) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._name) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._podcastsSortType) }()
        case 47: try { try decoder.decodeSingularMessageField(value: &_storage._dateAdded) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._userPodcastUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._episodeUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._podcastUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._isDeleted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._isDeletedModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._durationModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._playingStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._playingStatusModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._playedUpTo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._playedUpToModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._starred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._starredModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._timesStartedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._timeSilenceRemoval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._timeVariableSpeed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._timeIntroSkipping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._timeSkipping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._timeListened {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._autoStartFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._subscribed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._allPodcasts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._podcastUuids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._episodeUuids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._audioVideo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._notDownloaded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._downloaded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._downloading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._finished {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._partiallyPlayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._unplayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._manual {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._sortPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._sortType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._iconID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._filterHours {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._autoSkipLast {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._filterDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._longerThan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._shorterThan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._folderUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._podcastsSortType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._dateAdded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacyRecord, rhs: Api_LegacyRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._userPodcastUuid != rhs_storage._userPodcastUuid {return false}
        if _storage._episodeUuid != rhs_storage._episodeUuid {return false}
        if _storage._podcastUuid != rhs_storage._podcastUuid {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        if _storage._isDeletedModified != rhs_storage._isDeletedModified {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._durationModified != rhs_storage._durationModified {return false}
        if _storage._playingStatus != rhs_storage._playingStatus {return false}
        if _storage._playingStatusModified != rhs_storage._playingStatusModified {return false}
        if _storage._playedUpTo != rhs_storage._playedUpTo {return false}
        if _storage._playedUpToModified != rhs_storage._playedUpToModified {return false}
        if _storage._starred != rhs_storage._starred {return false}
        if _storage._starredModified != rhs_storage._starredModified {return false}
        if _storage._timesStartedAt != rhs_storage._timesStartedAt {return false}
        if _storage._timeSilenceRemoval != rhs_storage._timeSilenceRemoval {return false}
        if _storage._timeVariableSpeed != rhs_storage._timeVariableSpeed {return false}
        if _storage._timeIntroSkipping != rhs_storage._timeIntroSkipping {return false}
        if _storage._timeSkipping != rhs_storage._timeSkipping {return false}
        if _storage._timeListened != rhs_storage._timeListened {return false}
        if _storage._autoStartFrom != rhs_storage._autoStartFrom {return false}
        if _storage._subscribed != rhs_storage._subscribed {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._allPodcasts != rhs_storage._allPodcasts {return false}
        if _storage._podcastUuids != rhs_storage._podcastUuids {return false}
        if _storage._episodeUuids != rhs_storage._episodeUuids {return false}
        if _storage._audioVideo != rhs_storage._audioVideo {return false}
        if _storage._notDownloaded != rhs_storage._notDownloaded {return false}
        if _storage._downloaded != rhs_storage._downloaded {return false}
        if _storage._downloading != rhs_storage._downloading {return false}
        if _storage._finished != rhs_storage._finished {return false}
        if _storage._partiallyPlayed != rhs_storage._partiallyPlayed {return false}
        if _storage._unplayed != rhs_storage._unplayed {return false}
        if _storage._manual != rhs_storage._manual {return false}
        if _storage._sortPosition != rhs_storage._sortPosition {return false}
        if _storage._sortType != rhs_storage._sortType {return false}
        if _storage._iconID != rhs_storage._iconID {return false}
        if _storage._filterHours != rhs_storage._filterHours {return false}
        if _storage._autoSkipLast != rhs_storage._autoSkipLast {return false}
        if _storage._filterDuration != rhs_storage._filterDuration {return false}
        if _storage._longerThan != rhs_storage._longerThan {return false}
        if _storage._shorterThan != rhs_storage._shorterThan {return false}
        if _storage._folderUuid != rhs_storage._folderUuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._podcastsSortType != rhs_storage._podcastsSortType {return false}
        if _storage._dateAdded != rhs_storage._dateAdded {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacySyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacySyncResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_modified"),
    2: .same(proto: "changes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lastModified) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.changes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastModified.isEmpty {
      try visitor.visitSingularStringField(value: self.lastModified, fieldNumber: 1)
    }
    if !self.changes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacySyncResponse, rhs: Api_LegacySyncResponse) -> Bool {
    if lhs.lastModified != rhs.lastModified {return false}
    if lhs.changes != rhs.changes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacySyncResponseRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacySyncResponseRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._fields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacySyncResponseRecord, rhs: Api_LegacySyncResponseRecord) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._fields != rhs._fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacyResponseRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacyResponseRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "user_podcast_uuid"),
    3: .standard(proto: "episode_uuid"),
    4: .standard(proto: "podcast_uuid"),
    5: .standard(proto: "is_deleted"),
    6: .standard(proto: "is_deleted_modified"),
    7: .same(proto: "duration"),
    8: .standard(proto: "duration_modified"),
    9: .standard(proto: "playing_status"),
    10: .standard(proto: "playing_status_modified"),
    11: .standard(proto: "played_up_to"),
    12: .standard(proto: "played_up_to_modified"),
    13: .same(proto: "starred"),
    14: .standard(proto: "starred_modified"),
    15: .standard(proto: "times_started_at"),
    16: .standard(proto: "time_silence_removal"),
    17: .standard(proto: "time_variable_speed"),
    18: .standard(proto: "time_intro_skipping"),
    19: .standard(proto: "time_skipping"),
    20: .standard(proto: "time_listened"),
    21: .standard(proto: "auto_start_from"),
    22: .same(proto: "subscribed"),
    23: .same(proto: "title"),
    24: .standard(proto: "all_podcasts"),
    25: .standard(proto: "podcast_uuids"),
    26: .standard(proto: "episode_uuids"),
    27: .standard(proto: "audio_video"),
    28: .standard(proto: "not_downloaded"),
    29: .same(proto: "downloaded"),
    30: .same(proto: "downloading"),
    31: .same(proto: "finished"),
    32: .standard(proto: "partially_played"),
    33: .same(proto: "unplayed"),
    34: .same(proto: "manual"),
    35: .standard(proto: "sort_position"),
    36: .standard(proto: "sort_type"),
    37: .standard(proto: "icon_id"),
    38: .standard(proto: "filter_hours"),
    39: .standard(proto: "auto_skip_last"),
    40: .standard(proto: "filter_duration"),
    41: .standard(proto: "longer_than"),
    42: .standard(proto: "shorter_than"),
    43: .standard(proto: "folder_uuid"),
    44: .same(proto: "name"),
    45: .same(proto: "color"),
    46: .standard(proto: "podcasts_sort_type"),
    47: .standard(proto: "date_added"),
  ]

  fileprivate class _StorageClass {
    var _uuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _userPodcastUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _episodeUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _podcastUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _isDeleted: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _isDeletedModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _duration: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _durationModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _playingStatus: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _playingStatusModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _playedUpTo: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
    var _playedUpToModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _starred: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _starredModified: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _timesStartedAt: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _timeSilenceRemoval: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _timeVariableSpeed: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _timeIntroSkipping: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _timeSkipping: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _timeListened: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _autoStartFrom: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _subscribed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _title: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _allPodcasts: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _podcastUuids: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _episodeUuids: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _audioVideo: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _notDownloaded: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _downloaded: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _downloading: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _finished: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _partiallyPlayed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _unplayed: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _manual: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _sortPosition: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _sortType: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _iconID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _filterHours: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _autoSkipLast: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _filterDuration: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _longerThan: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _shorterThan: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _folderUuid: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _name: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _color: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _podcastsSortType: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _dateAdded: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _userPodcastUuid = source._userPodcastUuid
      _episodeUuid = source._episodeUuid
      _podcastUuid = source._podcastUuid
      _isDeleted = source._isDeleted
      _isDeletedModified = source._isDeletedModified
      _duration = source._duration
      _durationModified = source._durationModified
      _playingStatus = source._playingStatus
      _playingStatusModified = source._playingStatusModified
      _playedUpTo = source._playedUpTo
      _playedUpToModified = source._playedUpToModified
      _starred = source._starred
      _starredModified = source._starredModified
      _timesStartedAt = source._timesStartedAt
      _timeSilenceRemoval = source._timeSilenceRemoval
      _timeVariableSpeed = source._timeVariableSpeed
      _timeIntroSkipping = source._timeIntroSkipping
      _timeSkipping = source._timeSkipping
      _timeListened = source._timeListened
      _autoStartFrom = source._autoStartFrom
      _subscribed = source._subscribed
      _title = source._title
      _allPodcasts = source._allPodcasts
      _podcastUuids = source._podcastUuids
      _episodeUuids = source._episodeUuids
      _audioVideo = source._audioVideo
      _notDownloaded = source._notDownloaded
      _downloaded = source._downloaded
      _downloading = source._downloading
      _finished = source._finished
      _partiallyPlayed = source._partiallyPlayed
      _unplayed = source._unplayed
      _manual = source._manual
      _sortPosition = source._sortPosition
      _sortType = source._sortType
      _iconID = source._iconID
      _filterHours = source._filterHours
      _autoSkipLast = source._autoSkipLast
      _filterDuration = source._filterDuration
      _longerThan = source._longerThan
      _shorterThan = source._shorterThan
      _folderUuid = source._folderUuid
      _name = source._name
      _color = source._color
      _podcastsSortType = source._podcastsSortType
      _dateAdded = source._dateAdded
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userPodcastUuid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._episodeUuid) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._podcastUuid) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._isDeleted) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._isDeletedModified) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._duration) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._durationModified) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._playingStatus) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._playingStatusModified) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._playedUpTo) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._playedUpToModified) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._starred) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._starredModified) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._timesStartedAt) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._timeSilenceRemoval) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._timeVariableSpeed) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._timeIntroSkipping) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._timeSkipping) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._timeListened) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._autoStartFrom) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._subscribed) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._title) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._allPodcasts) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._podcastUuids) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._episodeUuids) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._audioVideo) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._notDownloaded) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._downloaded) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._downloading) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._finished) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._partiallyPlayed) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._unplayed) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._manual) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._sortPosition) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._sortType) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._iconID) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._filterHours) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._autoSkipLast) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._filterDuration) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._longerThan) }()
        case 42: try { try decoder.decodeSingularMessageField(value: &_storage._shorterThan) }()
        case 43: try { try decoder.decodeSingularMessageField(value: &_storage._folderUuid) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._name) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._podcastsSortType) }()
        case 47: try { try decoder.decodeSingularMessageField(value: &_storage._dateAdded) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._userPodcastUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._episodeUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._podcastUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._isDeleted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._isDeletedModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._durationModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._playingStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._playingStatusModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._playedUpTo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._playedUpToModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._starred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._starredModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._timesStartedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._timeSilenceRemoval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._timeVariableSpeed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._timeIntroSkipping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._timeSkipping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._timeListened {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._autoStartFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._subscribed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._allPodcasts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._podcastUuids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._episodeUuids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._audioVideo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._notDownloaded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._downloaded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._downloading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._finished {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._partiallyPlayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._unplayed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._manual {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._sortPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._sortType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._iconID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._filterHours {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._autoSkipLast {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._filterDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._longerThan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._shorterThan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._folderUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._podcastsSortType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._dateAdded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacyResponseRecord, rhs: Api_LegacyResponseRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._userPodcastUuid != rhs_storage._userPodcastUuid {return false}
        if _storage._episodeUuid != rhs_storage._episodeUuid {return false}
        if _storage._podcastUuid != rhs_storage._podcastUuid {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        if _storage._isDeletedModified != rhs_storage._isDeletedModified {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._durationModified != rhs_storage._durationModified {return false}
        if _storage._playingStatus != rhs_storage._playingStatus {return false}
        if _storage._playingStatusModified != rhs_storage._playingStatusModified {return false}
        if _storage._playedUpTo != rhs_storage._playedUpTo {return false}
        if _storage._playedUpToModified != rhs_storage._playedUpToModified {return false}
        if _storage._starred != rhs_storage._starred {return false}
        if _storage._starredModified != rhs_storage._starredModified {return false}
        if _storage._timesStartedAt != rhs_storage._timesStartedAt {return false}
        if _storage._timeSilenceRemoval != rhs_storage._timeSilenceRemoval {return false}
        if _storage._timeVariableSpeed != rhs_storage._timeVariableSpeed {return false}
        if _storage._timeIntroSkipping != rhs_storage._timeIntroSkipping {return false}
        if _storage._timeSkipping != rhs_storage._timeSkipping {return false}
        if _storage._timeListened != rhs_storage._timeListened {return false}
        if _storage._autoStartFrom != rhs_storage._autoStartFrom {return false}
        if _storage._subscribed != rhs_storage._subscribed {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._allPodcasts != rhs_storage._allPodcasts {return false}
        if _storage._podcastUuids != rhs_storage._podcastUuids {return false}
        if _storage._episodeUuids != rhs_storage._episodeUuids {return false}
        if _storage._audioVideo != rhs_storage._audioVideo {return false}
        if _storage._notDownloaded != rhs_storage._notDownloaded {return false}
        if _storage._downloaded != rhs_storage._downloaded {return false}
        if _storage._downloading != rhs_storage._downloading {return false}
        if _storage._finished != rhs_storage._finished {return false}
        if _storage._partiallyPlayed != rhs_storage._partiallyPlayed {return false}
        if _storage._unplayed != rhs_storage._unplayed {return false}
        if _storage._manual != rhs_storage._manual {return false}
        if _storage._sortPosition != rhs_storage._sortPosition {return false}
        if _storage._sortType != rhs_storage._sortType {return false}
        if _storage._iconID != rhs_storage._iconID {return false}
        if _storage._filterHours != rhs_storage._filterHours {return false}
        if _storage._autoSkipLast != rhs_storage._autoSkipLast {return false}
        if _storage._filterDuration != rhs_storage._filterDuration {return false}
        if _storage._longerThan != rhs_storage._longerThan {return false}
        if _storage._shorterThan != rhs_storage._shorterThan {return false}
        if _storage._folderUuid != rhs_storage._folderUuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._podcastsSortType != rhs_storage._podcastsSortType {return false}
        if _storage._dateAdded != rhs_storage._dateAdded {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_LegacyStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegacyStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "times_started_at"),
    2: .standard(proto: "time_silence_removal"),
    3: .standard(proto: "time_variable_speed"),
    4: .standard(proto: "time_intro_skipping"),
    5: .standard(proto: "time_skipping"),
    6: .standard(proto: "time_listened"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timesStartedAt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.timeSilenceRemoval) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timeVariableSpeed) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.timeIntroSkipping) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.timeSkipping) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.timeListened) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timesStartedAt != 0 {
      try visitor.visitSingularInt32Field(value: self.timesStartedAt, fieldNumber: 1)
    }
    if self.timeSilenceRemoval != 0 {
      try visitor.visitSingularInt32Field(value: self.timeSilenceRemoval, fieldNumber: 2)
    }
    if self.timeVariableSpeed != 0 {
      try visitor.visitSingularInt32Field(value: self.timeVariableSpeed, fieldNumber: 3)
    }
    if self.timeIntroSkipping != 0 {
      try visitor.visitSingularInt32Field(value: self.timeIntroSkipping, fieldNumber: 4)
    }
    if self.timeSkipping != 0 {
      try visitor.visitSingularInt32Field(value: self.timeSkipping, fieldNumber: 5)
    }
    if self.timeListened != 0 {
      try visitor.visitSingularInt32Field(value: self.timeListened, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_LegacyStatsResponse, rhs: Api_LegacyStatsResponse) -> Bool {
    if lhs.timesStartedAt != rhs.timesStartedAt {return false}
    if lhs.timeSilenceRemoval != rhs.timeSilenceRemoval {return false}
    if lhs.timeVariableSpeed != rhs.timeVariableSpeed {return false}
    if lhs.timeIntroSkipping != rhs.timeIntroSkipping {return false}
    if lhs.timeSkipping != rhs.timeSkipping {return false}
    if lhs.timeListened != rhs.timeListened {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PromotionCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromotionCode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PromotionCode, rhs: Api_PromotionCode) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Promotion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Promotion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
    3: .standard(proto: "starts_at"),
    4: .standard(proto: "ends_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.startsAt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.endsAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.startsAt.isEmpty {
      try visitor.visitSingularStringField(value: self.startsAt, fieldNumber: 3)
    }
    if !self.endsAt.isEmpty {
      try visitor.visitSingularStringField(value: self.endsAt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_Promotion, rhs: Api_Promotion) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.startsAt != rhs.startsAt {return false}
    if lhs.endsAt != rhs.endsAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PodcastSubscriptionCheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodcastSubscriptionCheckRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_uuid"),
    2: .standard(proto: "podcast_uuid"),
    3: .same(proto: "platform"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.podcastUuid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.platform) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.userUuid, fieldNumber: 1)
    }
    if !self.podcastUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastUuid, fieldNumber: 2)
    }
    if self.platform != 0 {
      try visitor.visitSingularInt32Field(value: self.platform, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PodcastSubscriptionCheckRequest, rhs: Api_PodcastSubscriptionCheckRequest) -> Bool {
    if lhs.userUuid != rhs.userUuid {return false}
    if lhs.podcastUuid != rhs.podcastUuid {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_BundleUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BundleUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_uuid"),
    2: .same(proto: "bundles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userUuid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.bundles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.userUuid, fieldNumber: 1)
    }
    if !self.bundles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.bundles, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_BundleUserRequest, rhs: Api_BundleUserRequest) -> Bool {
    if lhs.userUuid != rhs.userUuid {return false}
    if lhs.bundles != rhs.bundles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_BundleUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BundleUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_exists"),
    2: .same(proto: "paid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.userExists) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.paid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userExists != false {
      try visitor.visitSingularBoolField(value: self.userExists, fieldNumber: 1)
    }
    if self.paid != false {
      try visitor.visitSingularBoolField(value: self.paid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_BundleUserResponse, rhs: Api_BundleUserResponse) -> Bool {
    if lhs.userExists != rhs.userExists {return false}
    if lhs.paid != rhs.paid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PodcastSubscriptionCheckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodcastSubscriptionCheckResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paid"),
    2: .standard(proto: "user_exists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.paid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.userExists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.paid != false {
      try visitor.visitSingularBoolField(value: self.paid, fieldNumber: 1)
    }
    if self.userExists != false {
      try visitor.visitSingularBoolField(value: self.userExists, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PodcastSubscriptionCheckResponse, rhs: Api_PodcastSubscriptionCheckResponse) -> Bool {
    if lhs.paid != rhs.paid {return false}
    if lhs.userExists != rhs.userExists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PodcastFolderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodcastFolderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "model"),
    3: .same(proto: "folder"),
    4: .same(proto: "podcasts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._folder) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.podcasts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    try { if let v = self._folder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.podcasts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.podcasts, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PodcastFolderRequest, rhs: Api_PodcastFolderRequest) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.model != rhs.model {return false}
    if lhs._folder != rhs._folder {return false}
    if lhs.podcasts != rhs.podcasts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PodcastFolder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodcastFolder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "folder_uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "color"),
    4: .standard(proto: "sort_position"),
    5: .standard(proto: "podcasts_sort_type"),
    6: .standard(proto: "date_added"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.folderUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.color) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.sortPosition) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.podcastsSortType) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._dateAdded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.folderUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.folderUuid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.color != 0 {
      try visitor.visitSingularInt32Field(value: self.color, fieldNumber: 3)
    }
    if self.sortPosition != 0 {
      try visitor.visitSingularInt32Field(value: self.sortPosition, fieldNumber: 4)
    }
    if self.podcastsSortType != 0 {
      try visitor.visitSingularInt32Field(value: self.podcastsSortType, fieldNumber: 5)
    }
    try { if let v = self._dateAdded {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PodcastFolder, rhs: Api_PodcastFolder) -> Bool {
    if lhs.folderUuid != rhs.folderUuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.color != rhs.color {return false}
    if lhs.sortPosition != rhs.sortPosition {return false}
    if lhs.podcastsSortType != rhs.podcastsSortType {return false}
    if lhs._dateAdded != rhs._dateAdded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PodcastFolderSortRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodcastFolderSortRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "model"),
    3: .same(proto: "podcasts"),
    4: .same(proto: "folders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.podcasts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.folders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    if !self.podcasts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.podcasts, fieldNumber: 3)
    }
    if !self.folders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.folders, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PodcastFolderSortRequest, rhs: Api_PodcastFolderSortRequest) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.model != rhs.model {return false}
    if lhs.podcasts != rhs.podcasts {return false}
    if lhs.folders != rhs.folders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PodcastFolderSorting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PodcastFolderSorting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.position != 0 {
      try visitor.visitSingularInt32Field(value: self.position, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_PodcastFolderSorting, rhs: Api_PodcastFolderSorting) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
